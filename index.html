<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工程試算工具</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --bg: #f1f5f9;
            --card: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --success: #16a34a;
            --accent: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei", sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 700;
        }

        header p {
            font-size: 0.85rem;
            opacity: 0.85;
            margin-top: 0.25rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            background: var(--card);
            padding: 0.75rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .tab-btn {
            padding: 0.6rem 1.2rem;
            border: 2px solid transparent;
            background: var(--bg);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: #e0e7ff;
            color: var(--primary);
        }

        .tab-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Cards */
        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .card h2 {
            font-size: 1.2rem;
            margin-bottom: 0.25rem;
            color: var(--primary);
        }

        .card .subtitle {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .formula-display {
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            font-family: "Cambria Math", "Times New Roman", serif;
            font-size: 1rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Form */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.3rem;
            color: var(--text);
        }

        .form-group label span {
            font-weight: 400;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .form-group input,
        .form-group select {
            padding: 0.6rem 0.75rem;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
            background: white;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .input-unit-group {
            display: flex;
            gap: 0;
        }

        .input-unit-group input {
            flex: 1;
            border-radius: 8px 0 0 8px;
            border-right: none;
            min-width: 0;
        }

        .input-unit-group select.unit-select {
            width: auto;
            min-width: 70px;
            max-width: 100px;
            border-radius: 0 8px 8px 0;
            border-left: 1px solid var(--border);
            font-size: 0.8rem;
            padding: 0.4rem 0.3rem;
            background: #f8fafc;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .input-unit-group select.unit-select:focus {
            border-color: var(--primary);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.7rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 1rem;
        }

        .btn:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: #64748b;
        }

        .btn-secondary:hover {
            background: #475569;
        }

        /* Results */
        .result-box {
            margin-top: 1rem;
            padding: 1rem 1.25rem;
            background: #f0fdf4;
            border: 2px solid #bbf7d0;
            border-radius: 8px;
            display: none;
        }

        .result-box.show {
            display: block;
        }

        .result-box h3 {
            font-size: 0.9rem;
            color: var(--success);
            margin-bottom: 0.5rem;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            border-bottom: 1px dashed #e2e8f0;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-item .label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .result-item .value {
            font-weight: 700;
            color: var(--text);
            font-size: 0.95rem;
        }

        /* Diagram */
        .diagram-container {
            text-align: center;
            margin: 1rem 0;
        }

        .diagram-container svg {
            max-width: 100%;
            height: auto;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .tab-nav {
                gap: 0.35rem;
                padding: 0.5rem;
            }

            .tab-btn {
                padding: 0.5rem 0.8rem;
                font-size: 0.8rem;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Print */
        @media print {
            header {
                position: static;
            }

            .tab-nav,
            .btn {
                display: none;
            }

            .tab-content {
                display: block !important;
            }

            .card {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ccc;
            }
        }

        .unit-system-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .unit-system-selector label {
            font-size: 0.85rem;
            opacity: 0.85;
        }

        .unit-system-selector select {
            padding: 0.4rem 0.6rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
        }

        .unit-system-selector select option {
            color: #1e293b;
            background: white;
        }

        /* Coordinate tables for RC Column */
        .coord-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }

        .coord-table th,
        .coord-table td {
            border: 1px solid var(--border);
            padding: 0.3rem 0.5rem;
            text-align: center;
        }

        .coord-table th {
            background: var(--bg);
            font-weight: 600;
            font-size: 0.8rem;
        }

        .coord-table input {
            width: 70px;
            padding: 0.3rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            text-align: center;
            font-size: 0.85rem;
        }

        .coord-table input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .coord-table select {
            padding: 0.3rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .btn-sm {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            margin: 0.25rem 0.15rem;
        }

        .btn-sm-primary {
            background: var(--primary);
            color: white;
        }

        .btn-sm-primary:hover {
            background: var(--primary-dark);
        }

        .btn-sm-danger {
            background: #ef4444;
            color: white;
        }

        .btn-sm-danger:hover {
            background: #dc2626;
        }

        .btn-sm-secondary {
            background: #64748b;
            color: white;
        }

        .btn-sm-secondary:hover {
            background: #475569;
        }

        .section-block {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .section-block:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-block h3 {
            font-size: 1rem;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        #rcc-loads-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0.5rem;
        }

        #rcc-loads-table th,
        #rcc-loads-table td {
            border: 1px solid var(--border);
            padding: 4px 6px;
            text-align: center;
        }

        #rcc-loads-table th {
            background: #f1f5f9;
            font-size: 0.85rem;
            font-weight: 600;
        }

        #rcc-loads-table input {
            width: 90px;
            text-align: center;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px;
            font-size: 0.9rem;
        }

        .rcc-load-del {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fca5a5;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            padding: 2px 8px;
        }

        .rcc-load-del:hover {
            background: #fecaca;
        }

        #rcc-add-load {
            background: #dcfce7;
            color: #16a34a;
            border: 1px solid #86efac;
            border-radius: 6px;
            padding: 6px 14px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
        }

        #rcc-add-load:hover {
            background: #bbf7d0;
        }

        .preview-container {
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-container svg {
            max-width: 100%;
            height: auto;
        }

        .inline-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
    </style>
</head>

<body>

    <header>
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:0.5rem;">
            <div>
                <h1>&#9881; 工程試算工具</h1>
                <p>Engineering Calculator - 結構 / 材料 / 單位換算</p>
            </div>
            <div class="unit-system-selector">
                <label for="unit-system">選擇單位</label>
                <select id="unit-system" onchange="switchUnitSystem(this.value)">
                    <option value="">自訂</option>
                    <option value="kN-m">kN - m</option>
                    <option value="kgf-cm" selected>Kgf - cm</option>
                    <option value="tf-m">tf - m</option>
                    <option value="N-mm">N - mm</option>
                    <option value="tf-cm">tf - cm</option>
                    <option value="kgf-m">Kgf - m</option>
                </select>
            </div>
        </div>
    </header>

    <div class="container">
        <nav class="tab-nav">
            <button class="tab-btn active" data-tab="rccolumn">RC 柱交互作用曲線</button>
            <button class="tab-btn" data-tab="rcbeam">RC梁設計</button>
            <button class="tab-btn" data-tab="column">柱尺寸估算</button>
            <button class="tab-btn" data-tab="rebar">鋼筋計算</button>
            <button class="tab-btn" data-tab="unit">單位換算</button>
        </nav>

        <!-- ==================== 柱載重 ==================== -->
        <div class="tab-content" id="tab-column">
            <div class="card">
                <h2>柱軸壓載重分析</h2>
                <p class="subtitle">Euler 挫屈載重 & 容許軸壓力計算</p>
                <div class="formula-display">
                    P_cr = &pi;&sup2;EI / (KL)&sup2; &nbsp;&nbsp;|&nbsp;&nbsp; &sigma; = P / A
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label>彈性模數 E <span>(GPa)</span></label>
                        <input type="number" id="col-E" value="200" step="1">
                    </div>
                    <div class="form-group">
                        <label>慣性矩 I <span>(cm⁴)</span></label>
                        <input type="number" id="col-I" value="5696" step="1">
                    </div>
                    <div class="form-group">
                        <label>斷面積 A <span>(cm&sup2;)</span></label>
                        <input type="number" id="col-A" value="76.4" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>柱長度 L <span>(m)</span></label>
                        <input type="number" id="col-L" value="4" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>有效長度係數 K</label>
                        <select id="col-K">
                            <option value="0.5">0.5 - 兩端固定</option>
                            <option value="0.7">0.7 - 一端固定一端鉸</option>
                            <option value="1.0" selected>1.0 - 兩端鉸接</option>
                            <option value="2.0">2.0 - 一端固定一端自由</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>軸壓力 P <span>(kN)</span></label>
                        <input type="number" id="col-P" value="500" step="1">
                    </div>
                </div>
                <button class="btn" onclick="calcColumn()">計算</button>
                <div class="result-box" id="result-column">
                    <h3>計算結果</h3>
                    <div id="result-column-content"></div>
                </div>
            </div>
        </div>

        <!-- ==================== 鋼筋計算 ==================== -->
        <div class="tab-content" id="tab-rebar">
            <div class="card">
                <h2>鋼筋數量與重量計算</h2>
                <p class="subtitle">依據鋼筋號數計算單位重量、總重量</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>鋼筋號數</label>
                        <select id="rebar-no">
                            <option value="3">D10 (#3) - 0.560 kg/m</option>
                            <option value="4" selected>D13 (#4) - 0.994 kg/m</option>
                            <option value="5">D16 (#5) - 1.552 kg/m</option>
                            <option value="6">D19 (#6) - 2.235 kg/m</option>
                            <option value="7">D22 (#7) - 2.985 kg/m</option>
                            <option value="8">D25 (#8) - 3.980 kg/m</option>
                            <option value="9">D29 (#9) - 5.080 kg/m</option>
                            <option value="10">D32 (#10) - 6.390 kg/m</option>
                            <option value="11">D36 (#11) - 7.900 kg/m</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>單支長度 <span>(m)</span></label>
                        <input type="number" id="rebar-len" value="6" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>支數</label>
                        <input type="number" id="rebar-qty" value="20" step="1" min="1">
                    </div>
                    <div class="form-group">
                        <label>搭接率 <span>(%)</span></label>
                        <input type="number" id="rebar-lap" value="10" step="1" min="0">
                    </div>
                </div>
                <button class="btn" onclick="calcRebar()">計算</button>
                <div class="result-box" id="result-rebar">
                    <h3>計算結果</h3>
                    <div id="result-rebar-content"></div>
                </div>
            </div>
        </div>

        <!-- ==================== RC梁設計 ==================== -->
        <div class="tab-content" id="tab-rcbeam">
            <div class="card">
                <h2>RC梁撓曲設計 (ACI 318)</h2>
                <p class="subtitle">矩形梁（單筋／雙筋）- 依設計彎矩求所需鋼筋量</p>
                <div class="formula-display">
                    &phi;Mn &ge; Mu &nbsp;&nbsp;|&nbsp;&nbsp; a = As&middot;fy / (0.85&middot;f'c&middot;b)
                    &nbsp;&nbsp;|&nbsp;&nbsp; Mn = As&middot;fy&middot;(d - a/2)
                </div>
                <div class="diagram-container">
                    <svg width="360" height="180" viewBox="0 0 360 180">
                        <!-- beam cross section -->
                        <rect x="80" y="10" width="100" height="160" fill="none" stroke="#2563eb" stroke-width="2" />
                        <!-- concrete fill -->
                        <rect x="80" y="10" width="100" height="160" fill="#e0e7ff" opacity="0.5" />
                        <!-- compression rebar circles -->
                        <circle cx="110" cy="30" r="5" fill="#f59e0b" />
                        <circle cx="150" cy="30" r="5" fill="#f59e0b" />
                        <!-- tension rebar circles -->
                        <circle cx="105" cy="145" r="6" fill="#ef4444" />
                        <circle cx="130" cy="145" r="6" fill="#ef4444" />
                        <circle cx="155" cy="145" r="6" fill="#ef4444" />
                        <!-- dimensions: b -->
                        <line x1="80" y1="178" x2="180" y2="178" stroke="#64748b" stroke-width="1" />
                        <line x1="80" y1="174" x2="80" y2="178" stroke="#64748b" stroke-width="1" />
                        <line x1="180" y1="174" x2="180" y2="178" stroke="#64748b" stroke-width="1" />
                        <text x="130" y="176" text-anchor="middle" fill="#64748b" font-size="11">b</text>
                        <!-- dimensions: h -->
                        <line x1="72" y1="10" x2="72" y2="170" stroke="#64748b" stroke-width="1" />
                        <line x1="68" y1="10" x2="76" y2="10" stroke="#64748b" stroke-width="1" />
                        <line x1="68" y1="170" x2="76" y2="170" stroke="#64748b" stroke-width="1" />
                        <text x="64" y="94" text-anchor="middle" fill="#64748b" font-size="11"
                            transform="rotate(-90,64,94)">h</text>
                        <!-- dimensions: d -->
                        <line x1="188" y1="10" x2="188" y2="145" stroke="#ef4444" stroke-width="1"
                            stroke-dasharray="4" />
                        <line x1="184" y1="10" x2="192" y2="10" stroke="#ef4444" stroke-width="1" />
                        <line x1="184" y1="145" x2="192" y2="145" stroke="#ef4444" stroke-width="1" />
                        <text x="198" y="82" fill="#ef4444" font-size="11">d</text>
                        <!-- dimensions: d' -->
                        <line x1="198" y1="10" x2="198" y2="30" stroke="#f59e0b" stroke-width="1"
                            stroke-dasharray="4" />
                        <line x1="194" y1="30" x2="202" y2="30" stroke="#f59e0b" stroke-width="1" />
                        <text x="208" y="24" fill="#f59e0b" font-size="11">d'</text>
                        <!-- stress block -->
                        <rect x="230" y="10" width="60" height="50" fill="#3b82f6" opacity="0.3" stroke="#2563eb"
                            stroke-width="1" />
                        <text x="260" y="38" text-anchor="middle" fill="#2563eb" font-size="10">0.85f'c</text>
                        <text x="260" y="68" text-anchor="middle" fill="#2563eb" font-size="10">a</text>
                        <!-- arrow a -->
                        <line x1="295" y1="10" x2="295" y2="60" stroke="#2563eb" stroke-width="1" />
                        <polygon points="295,10 292,18 298,18" fill="#2563eb" />
                        <polygon points="295,60 292,52 298,52" fill="#2563eb" />
                        <!-- tension force -->
                        <line x1="260" y1="145" x2="260" y2="145" stroke="#ef4444" stroke-width="1" />
                        <text x="260" y="150" text-anchor="middle" fill="#ef4444" font-size="10">As&middot;fy</text>
                    </svg>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label>設計類型</label>
                        <select id="rc-type" onchange="toggleRcBeamType()">
                            <option value="single">單筋梁</option>
                            <option value="double">雙筋梁</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>梁寬 b <span>(cm)</span></label>
                        <input type="number" id="rc-b" value="30" step="1" min="1">
                    </div>
                    <div class="form-group">
                        <label>梁深 h <span>(cm)</span></label>
                        <input type="number" id="rc-h" value="60" step="1" min="1">
                    </div>
                    <div class="form-group">
                        <label>有效深度 d <span>(cm)</span></label>
                        <input type="number" id="rc-d" value="54" step="0.5" min="1">
                    </div>
                    <div class="form-group" id="rc-dc-group" style="display:none;">
                        <label>壓力筋深度 d' <span>(cm)</span></label>
                        <input type="number" id="rc-dc" value="6" step="0.5" min="1">
                    </div>
                    <div class="form-group">
                        <label>混凝土強度 f'c <span>(kgf/cm&sup2;)</span></label>
                        <input type="number" id="rc-fc" value="280" step="10" min="1">
                    </div>
                    <div class="form-group">
                        <label>鋼筋降伏強度 fy <span>(kgf/cm&sup2;)</span></label>
                        <input type="number" id="rc-fy" value="4200" step="100" min="1">
                    </div>
                    <div class="form-group">
                        <label>設計彎矩 Mu <span>(tf&middot;m)</span></label>
                        <input type="number" id="rc-Mu" value="15" step="0.5" min="0">
                    </div>
                    <div class="form-group">
                        <label>強度折減係數 &phi;</label>
                        <input type="number" id="rc-phi" value="0.9" step="0.05" min="0.1" max="1">
                    </div>
                </div>
                <button class="btn" onclick="calcRCBeam()">設計計算</button>
                <div class="result-box" id="result-rcbeam">
                    <h3>設計結果</h3>
                    <div id="result-rcbeam-content"></div>
                </div>
            </div>
        </div>

        <!-- ==================== RC柱設計 ==================== -->
        <div class="tab-content active" id="tab-rccolumn">
            <div class="card">
                <h2>RC柱設計 (P-Mx-My 交互作用)</h2>
                <p class="subtitle">任意形狀斷面 - 雙向軸力與彎矩交互作用分析</p>

                <!-- A. 斷面幾何 -->
                <div class="section-block">
                    <h3>A. 斷面幾何</h3>
                    <div style="margin-bottom:0.5rem;">
                        <button class="btn" style="background:#2563eb;" onclick="importRCColumnCSV()">匯入 CSV</button>
                    </div>
                    <div class="inline-controls">
                        <label style="font-size:0.85rem;font-weight:600;">預設形狀：</label>
                        <select id="rcc-preset" onchange="onPresetChange(this.value)"
                            style="padding:0.4rem 0.6rem;border:2px solid var(--border);border-radius:6px;font-size:0.85rem;">
                            <option value="">-- 自選 --</option>
                            <option value="rect">矩形</option>
                            <option value="circle">圓形</option>
                            <option value="tshape">T型</option>
                            <option value="lshape">L型</option>
                        </select>
                    </div>

                    <!-- 參數化輸入 -->
                    <div id="rcc-shape-params" class="form-grid" style="margin:0.5rem 0;display:none;"></div>

                    <!-- 外輪廓 -->
                    <p style="font-size:0.9rem;font-weight:600;margin:0.5rem 0 0.25rem;">外輪廓頂點 (cm)</p>
                    <table class="coord-table" id="rcc-outer-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>X</th>
                                <th>Y</th>
                            </tr>
                        </thead>
                        <tbody id="rcc-outer-body"></tbody>
                    </table>
                    <div>
                        <button class="btn-sm btn-sm-primary" onclick="addOuterPt()">+ 新增點</button>
                        <button class="btn-sm btn-sm-danger" onclick="removeOuterPt()">- 刪除最後一點</button>
                    </div>

                    <!-- 空心輪廓 -->
                    <div class="inline-controls" style="margin-top:0.75rem;">
                        <label style="font-size:0.85rem;font-weight:600;">空心類型：</label>
                        <select id="rcc-hollow-preset" onchange="onHollowPresetChange(this.value)"
                            style="padding:0.4rem 0.6rem;border:2px solid var(--border);border-radius:6px;font-size:0.85rem;">
                            <option value="none">無空心</option>
                            <option value="rect">空心矩形</option>
                            <option value="circle">空心圓形</option>
                            <option value="custom">自訂頂點</option>
                        </select>
                    </div>
                    <div id="rcc-hollow-params" class="form-grid" style="margin:0.5rem 0;display:none;"></div>
                    <div id="rcc-hollow-custom" style="display:none;">
                        <p style="font-size:0.9rem;font-weight:600;margin:0.5rem 0 0.25rem;">空心區域頂點 (cm)</p>
                        <table class="coord-table" id="rcc-hollow-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>X</th>
                                    <th>Y</th>
                                </tr>
                            </thead>
                            <tbody id="rcc-hollow-body"></tbody>
                        </table>
                        <div>
                            <button class="btn-sm btn-sm-primary" onclick="addHollowPt()">+ 新增點</button>
                            <button class="btn-sm btn-sm-danger" onclick="removeHollowPt()">- 刪除最後一點</button>
                        </div>
                    </div>
                </div>

                <!-- B. 鋼筋配置 -->
                <div class="section-block">
                    <h3>B. 鋼筋配置</h3>
                    <div class="form-grid" style="margin-bottom:1rem;">
                        <div class="form-group">
                            <label>最小鋼筋間距 <span>(cm)</span></label>
                            <input type="number" id="rcc-spacing" value="10" step="1" min="1">
                        </div>
                        <div class="form-group">
                            <label>單支鋼筋面積 <span>(cm²)</span></label>
                            <input type="number" id="rcc-barArea" value="5.07" step="0.01" min="0.1">
                        </div>
                        <div class="form-group">
                            <label>鋼筋比 ρg <span>(%)</span></label>
                            <input type="number" id="rcc-rhoG" value="" step="0.1" min="0.1" max="8"
                                placeholder="輸入後按計算"
                                oninput="calcBarAreaFromRhoG()">
                        </div>
                    </div>
                    <table class="coord-table" id="rcc-rebar-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>X (cm)</th>
                                <th>Y (cm)</th>
                                <th>號數</th>
                                <th>面積 (cm²)</th>
                            </tr>
                        </thead>
                        <tbody id="rcc-rebar-body"></tbody>
                    </table>
                    <div>
                        <button class="btn-sm btn-sm-primary" onclick="addRebar()">+ 新增鋼筋</button>
                        <button class="btn-sm btn-sm-danger" onclick="removeRebar()">- 刪除最後一根</button>
                        <button class="btn-sm btn-sm-secondary" onclick="autoArrangeRebar()">自動排列</button>
                    </div>
                </div>

                <!-- C. 斷面預覽 -->
                <div class="section-block">
                    <h3>C. 斷面預覽</h3>
                    <div class="preview-container" id="rcc-preview">
                        <svg id="rcc-svg" width="400" height="400" viewBox="0 0 400 400">
                            <text x="200" y="200" text-anchor="middle" fill="#94a3b8" font-size="14">尚無斷面資料</text>
                        </svg>
                    </div>
                </div>

                <!-- D. 材料參數 -->
                <div class="section-block">
                    <h3>D. 材料參數</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label>混凝土強度 f'c <span>(kgf/cm²)</span></label>
                            <input type="number" id="rcc-fc" value="280" step="10" min="1">
                        </div>
                        <div class="form-group">
                            <label>鋼筋降伏強度 fy <span>(kgf/cm²)</span></label>
                            <input type="number" id="rcc-fy" value="4200" step="100" min="1">
                        </div>
                        <div class="form-group">
                            <label>鋼筋彈性模數 Es <span>(kgf/cm²)</span></label>
                            <input type="number" id="rcc-Es" value="2040000" step="10000" min="1">
                        </div>
                    </div>
                </div>

                <!-- E. 載重條件 -->
                <div class="section-block">
                    <h3>E. 載重條件</h3>
                    <table id="rcc-loads-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Pu (tf)</th>
                                <th>Mux (tf·m)</th>
                                <th>Muy (tf·m)</th>
                                <th>α (°)</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="rcc-load-idx">1</td>
                                <td><input type="number" value="100" step="1"></td>
                                <td><input type="number" value="0" step="0.5" oninput="updateLoadAlphas()"></td>
                                <td><input type="number" value="50" step="0.5" oninput="updateLoadAlphas()"></td>
                                <td class="rcc-load-alpha">—</td>
                                <td><button class="rcc-load-del" onclick="removeLoadCase(this)">✕</button></td>
                            </tr>
                        </tbody>
                    </table>
                    <button id="rcc-add-load" onclick="addLoadCase()">＋ 新增載重組合</button>
                </div>

                <!-- F. 設計參數 -->
                <div class="section-block">
                    <h3>F. 設計參數</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label>設計規範</label>
                            <select id="rcc-code">
                                <option value="ACI318-14" selected>ACI 318-14</option>
                                <option value="ACI318-19">ACI 318-19</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>保護層厚度 ic <span>(cm)</span></label>
                            <input type="number" id="rcc-ic" value="4" step="0.5" min="1" onchange="updateCover()">
                        </div>
                        <div class="form-group">
                            <label>箍筋號數</label>
                            <select id="rcc-stirrup" onchange="updateCover()">
                                <option value="3">#3 (D10)</option>
                                <option value="4" selected>#4 (D13)</option>
                                <option value="5">#5 (D16)</option>
                                <option value="6">#6 (D19)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>鋼筋中心至外緣 <span>(cm)</span></label>
                            <input type="number" id="rcc-cover" value="5.27" step="0.01" readonly
                                style="background:#f1f5f9;">
                        </div>
                    </div>
                </div>

                <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                    <button class="btn" onclick="calcRCColumn()">計算交互作用曲線</button>
                    <button class="btn" style="background:#16a34a;" onclick="exportRCColumnCSV()">匯出 CSV</button>
                </div>
                <div class="result-box" id="result-rccolumn">
                    <h3>設計結果</h3>
                    <div id="result-rccolumn-content"></div>
                </div>
                <div id="pm-chart-2d-container" style="display:none;margin-top:1.5rem;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                        <h3 style="color:var(--primary);margin:0;">2D P-M 交互作用曲線</h3>
                        <div style="display:flex; align-items:center; gap:8px; font-size:0.9rem;">
                            <label>α 角度:
                                <input type="number" id="pm-2d-alpha" value="0" step="10" min="-360" max="360" style="width:70px;padding:2px 4px;"
                                    onchange="let v=parseFloat(this.value)||0; v=Math.max(-360,Math.min(360,v)); this.value=v; if(window.lastPMSurface) drawPMChart2D(window.lastPMSurface, window.lastLoadPoints, v)">
                            </label>
                            <span>°</span>
                        </div>
                    </div>
                    <div style="display:flex; gap:12px; align-items:flex-start;">
                        <svg id="pm-chart-2d-svg" width="520" height="480" viewBox="0 0 520 480"
                            style="background:#fafbfc;border:1px solid var(--border);border-radius:8px;"></svg>
                        <svg id="pm-2d-section-svg" width="300" height="300" viewBox="0 0 300 300"
                            style="background:#fafbfc;border:1px solid var(--border);border-radius:8px;"></svg>
                    </div>
                    <div id="pm-2d-status" style="margin-top:0.5rem;font-size:0.9rem;font-weight:600;"></div>
                </div>
                <div id="pm-chart-container" style="display:none;margin-top:1.5rem;">
                    <div
                        style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:0.5rem;">
                        <h3 style="color:var(--primary);margin:0;">3D P-M 交互作用圖</h3>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; gap:5px;">
                            <div id="pm-chart-settings"
                                style="display:flex; gap:10px; align-items:center; font-size:0.9rem; flex-wrap:wrap;">
                                <label>模式: <select id="pm-strength-type"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"
                                        style="padding:2px">
                                        <option value="design">設計值 (φPn, φMn)</option>
                                        <option value="nominal">標稱值 (Pn, Mn)</option>
                                    </select></label>
                                <label>曲面: <input type="color" id="pm-color-surf" value="#3b82f6"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                                <label>網格: <input type="color" id="pm-color-wire" value="#ffffff"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                                <label>安全: <input type="color" id="pm-color-safe" value="#16a34a"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                                <label>危險: <input type="color" id="pm-color-unsafe" value="#ef4444"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                                <label>透明度: <input type="range" id="pm-opacity" min="0.05" max="1.0" step="0.05"
                                        value="0.3" style="width:60px;vertical-align:middle"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                            </div>
                            <div style="display:flex; gap:10px; align-items:center; font-size:0.9rem;">
                                <label title="垂直向(Pu)比例">Z軸(Pu): <input type="number" id="pm-scale-z" value="1.0"
                                        step="0.1" min="0.1" max="5.0" style="width:50px"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                                <label title="水平向(Mu)比例">XY軸(Mu): <input type="number" id="pm-scale-xy" value="1.0"
                                        step="0.1" min="0.1" max="5.0" style="width:50px"
                                        onchange="if(window.lastPMSurface) drawPMChart3D(window.lastPMSurface, window.lastLoadPoints)"></label>
                            </div>
                        </div>
                    </div>
                    <svg id="pm-chart-svg" width="520" height="480" viewBox="0 0 520 480"
                        style="background:#fafbfc;border:1px solid var(--border);border-radius:8px;"></svg>
                    <div id="pm-status" style="margin-top:0.5rem;font-size:0.9rem;font-weight:600;"></div>
                </div>
            </div>
        </div>

        <!-- ==================== 單位換算 ==================== -->
        <div class="tab-content" id="tab-unit">
            <div class="card">
                <h2>工程單位換算</h2>
                <p class="subtitle">常用工程單位快速換算</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>換算類別</label>
                        <select id="unit-cat" onchange="updateUnitOptions()">
                            <option value="length">長度</option>
                            <option value="area">面積</option>
                            <option value="volume">體積</option>
                            <option value="force">力</option>
                            <option value="pressure">壓力</option>
                            <option value="moment">彎矩</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>數值</label>
                        <input type="number" id="unit-val" value="1" step="any">
                    </div>
                    <div class="form-group">
                        <label>從</label>
                        <select id="unit-from"></select>
                    </div>
                    <div class="form-group">
                        <label>到</label>
                        <select id="unit-to"></select>
                    </div>
                </div>
                <button class="btn" onclick="calcUnit()">換算</button>
                <div class="result-box" id="result-unit">
                    <h3>換算結果</h3>
                    <div id="result-unit-content"></div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>工程試算工具 &copy; 2026 | 僅供參考，實際工程設計請依規範辦理</p>
    </footer>

    <script>
        // ===== Tab Switching =====
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
            });
        });

        // ===== Helpers =====
        function val(id) { return parseFloat(document.getElementById(id).value) || 0; }
        function sel(id) { return document.getElementById(id).value; }

        function showResult(id, items) {
            const box = document.getElementById('result-' + id);
            const content = document.getElementById('result-' + id + '-content');
            content.innerHTML = items.map(([label, value]) =>
                `<div class="result-item"><span class="label">${label}</span><span class="value">${value}</span></div>`
            ).join('');
            box.classList.add('show');
        }

        function fmt(n, d = 4) {
            if (Math.abs(n) >= 1e6 || (Math.abs(n) < 0.001 && n !== 0)) return n.toExponential(d);
            return parseFloat(n.toFixed(d)).toLocaleString('en-US', { maximumFractionDigits: d });
        }

        // ===== SI 轉換因子 (所有單位 → SI 基準) =====
        const factorsToSI = {
            // Force → N
            'N': 1, 'kN': 1e3, 'kgf': 9.80665, 'tf': 9806.65, 'lbf': 4.44822,
            // Length → m
            'm': 1, 'cm': 0.01, 'mm': 0.001, 'ft': 0.3048, 'in': 0.0254,
            // Stress → Pa
            'Pa': 1, 'kPa': 1e3, 'MPa': 1e6, 'GPa': 1e9,
            'kN/m\u00B2': 1e3, 'kgf/cm\u00B2': 98066.5, 'tf/m\u00B2': 9806.65,
            'N/mm\u00B2': 1e6, 'tf/cm\u00B2': 98066500, 'kgf/m\u00B2': 9.80665,
            'ksi': 6894760, 'psi': 6894.76,
            // Moment → N·m
            'kN\u00B7m': 1e3, 'N\u00B7m': 1, 'kgf\u00B7cm': 0.0980665,
            'tf\u00B7m': 9806.65, 'N\u00B7mm': 0.001, 'tf\u00B7cm': 98.0665,
            'kgf\u00B7m': 9.80665, 'lbf\u00B7ft': 1.35582,
            // Distributed load → N/m
            'kN/m': 1e3, 'N/m': 1, 'kgf/cm': 980.665, 'tf/m': 9806.65,
            'N/mm': 1e3, 'tf/cm': 980665, 'kgf/m': 9.80665, 'lbf/ft': 14.5939,
            // Area → m²
            'm\u00B2': 1, 'cm\u00B2': 1e-4, 'mm\u00B2': 1e-6, 'in\u00B2': 6.4516e-4,
            // Inertia → m⁴
            'm\u2074': 1, 'cm\u2074': 1e-8, 'mm\u2074': 1e-12, 'in\u2074': 4.162314e-7,
            // Unit weight → N/m³
            'kN/m\u00B3': 1e3, 'kgf/cm\u00B3': 9806650, 'tf/m\u00B3': 9806.65,
            'N/mm\u00B3': 1e9, 'tf/cm\u00B3': 9.80665e9, 'kgf/m\u00B3': 9.80665, 'pcf': 157.087,
        };

        // ===== 單位制定義 =====
        const unitSystemDefs = {
            'kN-m': { length: 'm', force: 'kN', stress: 'kN/m\u00B2', load: 'kN/m', area: 'm\u00B2', inertia: 'm\u2074', unitweight: 'kN/m\u00B3', moment: 'kN\u00B7m' },
            'kgf-cm': { length: 'cm', force: 'kgf', stress: 'kgf/cm\u00B2', load: 'kgf/cm', area: 'cm\u00B2', inertia: 'cm\u2074', unitweight: 'kgf/cm\u00B3', moment: 'kgf\u00B7cm' },
            'tf-m': { length: 'm', force: 'tf', stress: 'tf/m\u00B2', load: 'tf/m', area: 'm\u00B2', inertia: 'm\u2074', unitweight: 'tf/m\u00B3', moment: 'tf\u00B7m' },
            'N-mm': { length: 'mm', force: 'N', stress: 'N/mm\u00B2', load: 'N/mm', area: 'mm\u00B2', inertia: 'mm\u2074', unitweight: 'N/mm\u00B3', moment: 'N\u00B7mm' },
            'tf-cm': { length: 'cm', force: 'tf', stress: 'tf/cm\u00B2', load: 'tf/cm', area: 'cm\u00B2', inertia: 'cm\u2074', unitweight: 'tf/cm\u00B3', moment: 'tf\u00B7cm' },
            'kgf-m': { length: 'm', force: 'kgf', stress: 'kgf/m\u00B2', load: 'kgf/m', area: 'm\u00B2', inertia: 'm\u2074', unitweight: 'kgf/m\u00B3', moment: 'kgf\u00B7m' },
        };

        // ===== 單位定義 (含維度類型) =====
        const fieldUnits = {
            // -- 柱載重 --
            'col-E': { dflt: 'GPa', dim: 'stress', units: { 'GPa': 1e6, 'MPa': 1e3, 'kN/m\u00B2': 1, 'kgf/cm\u00B2': 98.0665, 'tf/m\u00B2': 9.80665, 'N/mm\u00B2': 1e3, 'tf/cm\u00B2': 98066.5, 'kgf/m\u00B2': 0.00980665, 'ksi': 6.89476e3 } },
            'col-I': { dflt: 'cm\u2074', dim: 'inertia', units: { 'm\u2074': 1, 'cm\u2074': 1e-8, 'mm\u2074': 1e-12, 'in\u2074': 4.162314e-7 } },
            'col-A': { dflt: 'cm\u00B2', dim: 'area', units: { 'm\u00B2': 1, 'cm\u00B2': 1e-4, 'mm\u00B2': 1e-6, 'in\u00B2': 6.4516e-4 } },
            'col-L': { dflt: 'm', dim: 'length', units: { 'm': 1, 'cm': 0.01, 'mm': 0.001, 'ft': 0.3048 } },
            'col-P': { dflt: 'kN', dim: 'force', units: { 'kN': 1, 'N': 0.001, 'kgf': 0.00980665, 'tf': 9.80665, 'lbf': 0.00444822 } },

            // -- 鋼筋 --
            'rebar-len': { dflt: 'm', dim: 'length', units: { 'm': 1, 'cm': 0.01, 'mm': 0.001, 'ft': 0.3048 } },

            // -- RC梁設計 --
            'rc-b': { dflt: 'cm', dim: 'length', units: { 'cm': 1, 'mm': 0.1, 'm': 100, 'in': 2.54 } },
            'rc-h': { dflt: 'cm', dim: 'length', units: { 'cm': 1, 'mm': 0.1, 'm': 100, 'in': 2.54 } },
            'rc-d': { dflt: 'cm', dim: 'length', units: { 'cm': 1, 'mm': 0.1, 'm': 100, 'in': 2.54 } },
            'rc-dc': { dflt: 'cm', dim: 'length', units: { 'cm': 1, 'mm': 0.1, 'm': 100, 'in': 2.54 } },
            'rc-fc': { dflt: 'kgf/cm\u00B2', dim: 'stress', units: { 'kgf/cm\u00B2': 1, 'MPa': 10.1972, 'N/mm\u00B2': 10.1972, 'tf/m\u00B2': 0.1, 'kN/m\u00B2': 0.0101972, 'psi': 0.070307 } },
            'rc-fy': { dflt: 'kgf/cm\u00B2', dim: 'stress', units: { 'kgf/cm\u00B2': 1, 'MPa': 10.1972, 'N/mm\u00B2': 10.1972, 'tf/m\u00B2': 0.1, 'kN/m\u00B2': 0.0101972, 'psi': 0.070307 } },
            'rc-Mu': { dflt: 'tf\u00B7m', dim: 'moment', units: { 'tf\u00B7m': 1, 'kN\u00B7m': 0.101972, 'kgf\u00B7cm': 1e-5, 'kgf\u00B7m': 1e-3, 'N\u00B7mm': 1.01972e-7, 'tf\u00B7cm': 0.01, 'N\u00B7m': 1.01972e-4 } },

            // -- RC柱設計 --
            'rcc-fc': { dflt: 'kgf/cm\u00B2', dim: 'stress', units: { 'kgf/cm\u00B2': 1, 'MPa': 10.1972, 'N/mm\u00B2': 10.1972, 'tf/m\u00B2': 0.1, 'kN/m\u00B2': 0.0101972, 'psi': 0.070307 } },
            'rcc-fy': { dflt: 'kgf/cm\u00B2', dim: 'stress', units: { 'kgf/cm\u00B2': 1, 'MPa': 10.1972, 'N/mm\u00B2': 10.1972, 'tf/m\u00B2': 0.1, 'kN/m\u00B2': 0.0101972, 'psi': 0.070307 } },
            'rcc-Es': { dflt: 'kgf/cm\u00B2', dim: 'stress', units: { 'kgf/cm\u00B2': 1, 'MPa': 10.1972, 'N/mm\u00B2': 10.1972, 'tf/m\u00B2': 0.1, 'kN/m\u00B2': 0.0101972, 'psi': 0.070307 } },
            'rcc-Pu': { dflt: 'tf', dim: 'force', units: { 'tf': 1, 'kN': 0.101972, 'kgf': 1e-3, 'N': 1.01972e-4, 'lbf': 4.53592e-4 } },
            'rcc-Mux': { dflt: 'tf\u00B7m', dim: 'moment', units: { 'tf\u00B7m': 1, 'kN\u00B7m': 0.101972, 'kgf\u00B7cm': 1e-5, 'kgf\u00B7m': 1e-3, 'tf\u00B7cm': 0.01, 'N\u00B7m': 1.01972e-4 } },
            'rcc-Muy': { dflt: 'tf\u00B7m', dim: 'moment', units: { 'tf\u00B7m': 1, 'kN\u00B7m': 0.101972, 'kgf\u00B7cm': 1e-5, 'kgf\u00B7m': 1e-3, 'tf\u00B7cm': 0.01, 'N\u00B7m': 1.01972e-4 } },
            'rcc-ic': { dflt: 'cm', dim: 'length', units: { 'cm': 1, 'mm': 0.1, 'm': 100, 'in': 2.54 } },
            'rcc-spacing': { dflt: 'cm', dim: 'length', units: { 'cm': 1, 'mm': 0.1, 'm': 100, 'in': 2.54 } },
            'rcc-barArea': { dflt: 'cm²', dim: 'area', units: { 'cm²': 1, 'mm²': 0.01, 'in²': 6.4516 } },
        };

        // 讀取數值並轉換到基準單位
        function valU(id) {
            const v = parseFloat(document.getElementById(id).value) || 0;
            const fu = fieldUnits[id];
            if (!fu) return v;
            const unitSel = document.getElementById(id + '-unit');
            if (!unitSel) return v;
            const factor = fu.units[unitSel.value] || 1;
            return v * factor;
        }

        // 動態建立單位選擇器
        function initUnitSelectors() {
            for (const [id, cfg] of Object.entries(fieldUnits)) {
                const input = document.getElementById(id);
                if (!input) continue;

                // 移除 label 中的單位提示 <span>
                const label = input.closest('.form-group').querySelector('label span');
                if (label) label.remove();

                // 建立 unit select
                const select = document.createElement('select');
                select.id = id + '-unit';
                select.className = 'unit-select';
                for (const [uName] of Object.entries(cfg.units)) {
                    const opt = document.createElement('option');
                    opt.value = uName;
                    opt.textContent = uName;
                    if (uName === cfg.dflt) opt.selected = true;
                    select.appendChild(opt);
                }

                // 包裝 input + select
                const wrapper = document.createElement('div');
                wrapper.className = 'input-unit-group';
                input.parentNode.insertBefore(wrapper, input);
                wrapper.appendChild(input);
                wrapper.appendChild(select);
            }
        }

        // ===== 全域單位制切換 =====
        function switchUnitSystem(system) {
            if (!system) return;
            const sysDef = unitSystemDefs[system];
            if (!sysDef) return;

            for (const [fieldId, cfg] of Object.entries(fieldUnits)) {
                if (!cfg.dim) continue;
                const targetUnit = sysDef[cfg.dim];
                if (!targetUnit) continue;
                if (!cfg.units[targetUnit]) continue;

                const input = document.getElementById(fieldId);
                const unitSel = document.getElementById(fieldId + '-unit');
                if (!input || !unitSel) continue;

                const currentUnit = unitSel.value;
                if (currentUnit === targetUnit) continue;

                const oldFactor = cfg.units[currentUnit] || 1;
                const newFactor = cfg.units[targetUnit] || 1;
                const currentVal = parseFloat(input.value) || 0;
                const newVal = currentVal * oldFactor / newFactor;

                input.value = parseFloat(newVal.toPrecision(6));
                unitSel.value = targetUnit;
            }
        }

        // ===== 計算結果單位轉換 =====
        function resultInSystem(value, fromUnit, dim) {
            const sys = document.getElementById('unit-system').value;
            if (!sys) return { v: value, u: fromUnit };
            const sysDef = unitSystemDefs[sys];
            const toUnit = sysDef[dim];
            if (!toUnit || toUnit === fromUnit) return { v: value, u: fromUnit };
            const fromF = factorsToSI[fromUnit];
            const toF = factorsToSI[toUnit];
            if (!fromF || !toF) return { v: value, u: fromUnit };
            return { v: value * fromF / toF, u: toUnit };
        }

        // ===== 柱載重 =====
        function calcColumn() {
            const E = valU('col-E');
            const I = valU('col-I');
            const A = valU('col-A');
            const L = valU('col-L');
            const K = parseFloat(sel('col-K'));
            const P = valU('col-P');
            const Pcr = Math.PI * Math.PI * E * I / Math.pow(K * L, 2);
            const sigma = P / A; // kN/m²
            const sigmaMPa = sigma / 1000;
            const r = Math.sqrt(I / A);
            const slenderness = K * L / r;
            const fs = Pcr / P;

            const rPcr = resultInSystem(Pcr, 'kN', 'force');
            const rSigma = resultInSystem(sigmaMPa, 'MPa', 'stress');
            const rR = resultInSystem(r * 100, 'cm', 'length');

            showResult('column', [
                ['Euler \u631C\u5C48\u8F09\u91CD P_cr', fmt(rPcr.v, 1) + ' ' + rPcr.u],
                ['\u8EF8\u58D3\u61C9\u529B \u03C3', fmt(rSigma.v, 2) + ' ' + rSigma.u],
                ['\u8FF4\u8F49\u534A\u5F91 r', fmt(rR.v, 2) + ' ' + rR.u],
                ['\u7D30\u9577\u6BD4 KL/r', fmt(slenderness, 1)],
                ['\u5B89\u5168\u4FC2\u6578 P_cr/P', fmt(fs, 2)],
                ['\u72C0\u614B', fs >= 1.0 ? '\u2705 \u5B89\u5168' : '\u26A0\uFE0F \u8D85\u904E\u631C\u5C48\u8F09\u91CD\uFF01'],
            ]);
        }

        // ===== 鋼筋計算 =====
        function calcRebar() {
            const rebarData = {
                3: { dia: 9.53, weight: 0.560, name: 'D10 (#3)' },
                4: { dia: 12.7, weight: 0.994, name: 'D13 (#4)' },
                5: { dia: 15.9, weight: 1.552, name: 'D16 (#5)' },
                6: { dia: 19.1, weight: 2.235, name: 'D19 (#6)' },
                7: { dia: 22.2, weight: 2.985, name: 'D22 (#7)' },
                8: { dia: 25.4, weight: 3.980, name: 'D25 (#8)' },
                9: { dia: 28.7, weight: 5.080, name: 'D29 (#9)' },
                10: { dia: 32.3, weight: 6.390, name: 'D32 (#10)' },
                11: { dia: 35.8, weight: 7.900, name: 'D36 (#11)' },
            };
            const no = sel('rebar-no');
            const len = valU('rebar-len'), qty = val('rebar-qty'), lap = val('rebar-lap');
            const rb = rebarData[no];
            const totalLen = len * qty * (1 + lap / 100);
            const totalWeight = totalLen * rb.weight;
            const area = Math.PI * Math.pow(rb.dia / 2, 2);
            showResult('rebar', [
                ['\u92FC\u7B4B\u898F\u683C', rb.name],
                ['\u76F4\u5F91', rb.dia + ' mm'],
                ['\u55AE\u4F4D\u91CD', rb.weight + ' kg/m'],
                ['\u55AE\u652F\u65B7\u9762\u7A4D', fmt(area, 1) + ' mm\u00B2'],
                ['\u7E3D\u9577\u5EA6 (\u542B\u642D\u63A5)', fmt(totalLen, 2) + ' m'],
                ['\u7E3D\u91CD\u91CF', fmt(totalWeight, 1) + ' kg (' + fmt(totalWeight / 1000, 3) + ' t)'],
            ]);
        }

        // ===== RC梁撓曲設計 =====
        function toggleRcBeamType() {
            const isDouble = sel('rc-type') === 'double';
            document.getElementById('rc-dc-group').style.display = isDouble ? '' : 'none';
        }

        function calcRCBeam() {
            // 所有計算以 kgf-cm 為基準
            const b = valU('rc-b');    // cm
            const h = valU('rc-h');    // cm
            const d = valU('rc-d');    // cm
            const dc = valU('rc-dc'); // cm (壓力鋼筋深度 d')
            const fc = valU('rc-fc');  // kgf/cm²
            const fy = valU('rc-fy');  // kgf/cm²
            const Mu_tfm = valU('rc-Mu'); // tf·m
            const phi = val('rc-phi');
            const Es = 2.04e6; // kgf/cm² (鋼筋彈性模數)

            // 轉換 Mu: tf·m → kgf·cm
            const Mu = Mu_tfm * 1e5; // 1 tf·m = 100000 kgf·cm

            // β1 係數 (ACI 318)
            // f'c 以 MPa 判斷: 1 kgf/cm² = 0.0980665 MPa
            const fc_MPa = fc * 0.0980665;
            let beta1;
            if (fc_MPa <= 28) {
                beta1 = 0.85;
            } else {
                beta1 = 0.85 - 0.05 * (fc_MPa - 28) / 7;
                if (beta1 < 0.65) beta1 = 0.65;
            }

            // 最大鋼筋比 (確保拉力控制, εt ≥ 0.005)
            const rho_max = 0.85 * beta1 * (fc / fy) * (0.003 / (0.003 + 0.005));

            // 最小鋼筋比 (ACI 318-14 §9.6.1.2)
            const rho_min1 = 0.8 * Math.sqrt(fc_MPa) / (fy * 0.0980665);
            const rho_min2 = 14 / fy;
            const rho_min = Math.max(rho_min1, rho_min2);

            // Rn 法求所需鋼筋量
            const Mn_req = Mu / phi; // kgf·cm
            const Rn = Mn_req / (b * d * d); // kgf/cm²

            // 檢查是否超過單筋梁容量
            const Rn_max = rho_max * fy * (1 - 0.59 * rho_max * fy / fc);

            const userType = sel('rc-type'); // 'single' or 'double'
            let rho_req, As_req, a, Mn_provided;
            let status = '';
            let isDoubly = false;
            let isOverSingle = (Rn > Rn_max);
            let As1 = 0, As2 = 0, As_comp = 0, fs_comp = 0, compYielded = false;

            // 建議配筋輔助函式
            const rebarOptions = [
                { no: '#4 (D13)', dia: 1.27, area: 1.267 },
                { no: '#5 (D16)', dia: 1.59, area: 1.986 },
                { no: '#6 (D19)', dia: 1.91, area: 2.865 },
                { no: '#7 (D22)', dia: 2.22, area: 3.871 },
                { no: '#8 (D25)', dia: 2.54, area: 5.067 },
                { no: '#9 (D29)', dia: 2.87, area: 6.469 },
                { no: '#10 (D32)', dia: 3.23, area: 8.143 },
            ];
            function suggestBars(asNeeded) {
                for (const rb of rebarOptions) {
                    const nBars = Math.ceil(asNeeded / rb.area);
                    const totalAs = nBars * rb.area;
                    const clearWidth = b - 2 * 4 - 2 * 1.27; // 4cm 保護層 + #4 箍筋
                    const spacing = nBars > 1 ? (clearWidth - nBars * rb.dia) / (nBars - 1) : clearWidth;
                    if (spacing >= 2.5 && nBars <= 8) {
                        const rAs = resultInSystem(totalAs, 'cm\u00B2', 'area');
                        return nBars + '-' + rb.no + ' (As=' + fmt(rAs.v, 2) + ' ' + rAs.u + ')';
                    }
                }
                return '\u8ACB\u8ABF\u6574\u65B7\u9762\u6216\u63A1\u7528\u96D9\u5C64\u914D\u7B4B';
            }

            // 單筋梁最大容量 (兩種模式都需要)
            const As1_max = rho_max * b * d;
            const a1_max = As1_max * fy / (0.85 * fc * b);
            const Mn1_max = As1_max * fy * (d - a1_max / 2); // kgf·cm

            if (userType === 'double') {
                // ===== 雙筋梁設計 =====
                isDoubly = true;

                if (Mn_req <= Mn1_max) {
                    // Mu 在單筋梁容量內，壓力鋼筋按最小需求計算
                    // 以單筋梁求得 As_tension，As' = 0
                    const term = 2 * Rn / (0.85 * fc);
                    rho_req = (term >= 1) ? rho_max : (0.85 * fc / fy) * (1 - Math.sqrt(1 - term));
                    if (rho_req < rho_min) rho_req = rho_min;
                    As1 = rho_req * b * d;
                    As_req = As1;
                    As_comp = 0;
                    As2 = 0;
                    a = As_req * fy / (0.85 * fc * b);
                    Mn_provided = phi * As_req * fy * (d - a / 2);
                    fs_comp = fy;
                    compYielded = true;
                } else {
                    // Mu 超過單筋梁容量，需壓力鋼筋
                    As1 = As1_max;
                    const Mn2 = Mn_req - Mn1_max;

                    // 中性軸深度 (以 As1 計算)
                    const c1 = a1_max / beta1;

                    // 壓力鋼筋應力 (檢查是否降伏)
                    const eps_comp = 0.003 * (c1 - dc) / c1;
                    fs_comp = Math.min(Es * eps_comp, fy);
                    compYielded = (fs_comp >= fy);

                    // 壓力鋼筋面積
                    As_comp = Mn2 / (fs_comp * (d - dc));

                    // 對應額外拉力鋼筋
                    As2 = As_comp * fs_comp / fy;

                    // 總拉力鋼筋
                    As_req = As1 + As2;
                    rho_req = As_req / (b * d);
                    a = (As_req * fy - As_comp * fs_comp) / (0.85 * fc * b);

                    // 驗算 φMn
                    const c_final = a / beta1;
                    const eps_comp_final = 0.003 * (c_final - dc) / c_final;
                    const fs_comp_final = Math.min(Es * eps_comp_final, fy);
                    Mn_provided = phi * (0.85 * fc * a * b * (d - a / 2) + As_comp * fs_comp_final * (d - dc));
                }

            } else {
                // ===== 單筋梁設計 =====
                if (isOverSingle) {
                    // 超過單筋梁容量，以 ρmax 計算並警告
                    rho_req = rho_max;
                    As_req = rho_max * b * d;
                    a = As_req * fy / (0.85 * fc * b);
                    Mn_provided = phi * As_req * fy * (d - a / 2);
                } else {
                    const term = 2 * Rn / (0.85 * fc);
                    if (term >= 1) {
                        rho_req = rho_max;
                    } else {
                        rho_req = (0.85 * fc / fy) * (1 - Math.sqrt(1 - term));
                    }
                    if (rho_req < rho_min) rho_req = rho_min;
                    As_req = rho_req * b * d;
                    a = As_req * fy / (0.85 * fc * b);
                    Mn_provided = phi * As_req * fy * (d - a / 2);
                }
            }

            // c 值與淨拉應變
            const c = a / beta1;
            const epsilon_t = 0.003 * (d - c) / c;

            // 判斷狀態
            if (isDoubly && As_comp > 0) {
                status = '\u2705 \u96D9\u7B4B\u6881\u8A2D\u8A08' +
                    (compYielded ? ' (\u58D3\u529B\u7B4B\u5DF2\u964D\u4F0F)' : ' (\u58D3\u529B\u7B4B\u672A\u964D\u4F0F)');
            } else if (isDoubly && As_comp === 0) {
                if (epsilon_t >= 0.005)
                    status = '\u2705 \u96D9\u7B4B\u6881 \u2014 Mu\u5728\u55AE\u7B4B\u5BB9\u91CF\u5167\uFF0C\u7121\u9700\u58D3\u529B\u7B4B';
                else
                    status = '\u26A0\uFE0F \u96D9\u7B4B\u6881 \u2014 Mu\u5728\u55AE\u7B4B\u5BB9\u91CF\u5167\uFF0C\u7121\u9700\u58D3\u529B\u7B4B';
            } else if (isOverSingle) {
                status = '\u26A0\uFE0F \u8D85\u904E\u55AE\u7B4B\u6881\u5BB9\u91CF\uFF0C\u8ACB\u6539\u7528\u96D9\u7B4B\u6881\u6216\u52A0\u5927\u65B7\u9762';
            } else if (epsilon_t >= 0.005) {
                status = '\u2705 \u62C9\u529B\u63A7\u5236\u65B7\u9762 (\u03B5t \u2265 0.005)';
            } else if (epsilon_t >= 0.004) {
                status = '\u26A0\uFE0F \u904E\u6E21\u5340\u65B7\u9762 (0.004 \u2264 \u03B5t < 0.005)';
            } else {
                status = '\u274C \u58D3\u529B\u63A7\u5236\u65B7\u9762 (\u03B5t < 0.004)';
            }

            // 輸出結果 — 所有有量綱值透過 resultInSystem 轉換
            const rMu = resultInSystem(Mu_tfm, 'tf\u00B7m', 'moment');
            const rMn = resultInSystem(Mn_provided / 1e5, 'tf\u00B7m', 'moment');
            const rMn1max = resultInSystem(Mn1_max * phi / 1e5, 'tf\u00B7m', 'moment');
            const rAs = resultInSystem(As_req, 'cm\u00B2', 'area');
            const ra  = resultInSystem(a, 'cm', 'length');
            const rc  = resultInSystem(c, 'cm', 'length');

            const results = [
                ['\u8A2D\u8A08\u5F4E\u77E9 Mu', fmt(rMu.v, 2) + ' ' + rMu.u],
            ];

            if (isDoubly) {
                // --- 雙筋梁結果 ---
                results.push(
                    ['\u55AE\u7B4B\u6881\u6700\u5927 \u03C6Mn1', fmt(rMn1max.v, 2) + ' ' + rMn1max.u],
                    ['\u62C9\u529B\u92FC\u7B4B As', fmt(rAs.v, 2) + ' ' + rAs.u],
                    ['\u5EFA\u8B70\u62C9\u529B\u7B4B', suggestBars(As_req)],
                );
                if (As_comp > 0) {
                    const rAsc = resultInSystem(As_comp, 'cm\u00B2', 'area');
                    const rFs  = resultInSystem(fs_comp, 'kgf/cm\u00B2', 'stress');
                    results.push(
                        ['\u58D3\u529B\u92FC\u7B4B As\'', fmt(rAsc.v, 2) + ' ' + rAsc.u],
                        ['\u58D3\u529B\u7B4B\u61C9\u529B f\'s', fmt(rFs.v, 0) + ' ' + rFs.u + (compYielded ? ' (=fy)' : '')],
                        ['\u5EFA\u8B70\u58D3\u529B\u7B4B', suggestBars(As_comp)],
                    );
                } else {
                    results.push(
                        ['\u58D3\u529B\u92FC\u7B4B As\'', '0 (\u7121\u9700\u58D3\u529B\u7B4B)'],
                    );
                }
            } else {
                // --- 單筋梁結果 ---
                results.push(
                    ['\u6240\u9700\u92FC\u7B4B\u91CF As', fmt(rAs.v, 2) + ' ' + rAs.u],
                    ['\u92FC\u7B4B\u6BD4 \u03C1', fmt(rho_req * 100, 3) + ' %'],
                    ['\u5EFA\u8B70\u914D\u7B4B', suggestBars(As_req)],
                );
                if (isOverSingle) {
                    results.push(
                        ['\u55AE\u7B4B\u6881\u6700\u5927 \u03C6Mn', fmt(rMn1max.v, 2) + ' ' + rMn1max.u],
                    );
                }
            }

            results.push(
                ['\u6700\u5C0F\u92FC\u7B4B\u6BD4 \u03C1min', fmt(rho_min * 100, 3) + ' %'],
                ['\u6700\u5927\u92FC\u7B4B\u6BD4 \u03C1max', fmt(rho_max * 100, 3) + ' %'],
                ['\u61C9\u529B\u584A\u6DF1\u5EA6 a', fmt(ra.v, 2) + ' ' + ra.u],
                ['\u4E2D\u6027\u8EF8\u6DF1\u5EA6 c', fmt(rc.v, 2) + ' ' + rc.u],
                ['\u6DE8\u62C9\u61C9\u8B8A \u03B5t', fmt(epsilon_t, 4)],
                ['\u03B21', fmt(beta1, 3)],
                ['\u63D0\u4F9B\u5F4E\u77E9 \u03C6Mn', fmt(rMn.v, 2) + ' ' + rMn.u],
                ['\u65B7\u9762\u72C0\u614B', status],
            );

            showResult('rcbeam', results);
        }

        // ===== RC柱設計 =====
        const rcColData = {
            outer: [],   // [{x, y}, ...]
            hollow: [],  // [{x, y}, ...]
            rebars: [],  // [{x, y, no, area}, ...]
            pcX: null, pcY: null, alpha: null,  // 塑性中心與方位角 (計算後填入)
        };

        const rebarInfo = {
            0: { dia: 2, area: 0, name: '自訂' },
            3: { dia: 0.953, area: 0.7133, name: '#3 (D10)' },
            4: { dia: 1.27, area: 1.267, name: '#4 (D13)' },
            5: { dia: 1.59, area: 1.986, name: '#5 (D16)' },
            6: { dia: 1.91, area: 2.865, name: '#6 (D19)' },
            7: { dia: 2.22, area: 3.871, name: '#7 (D22)' },
            8: { dia: 2.54, area: 5.067, name: '#8 (D25)' },
            9: { dia: 2.87, area: 6.469, name: '#9 (D29)' },
            10: { dia: 3.23, area: 8.143, name: '#10 (D32)' },
            11: { dia: 3.58, area: 10.06, name: '#11 (D36)' },
        };

        function rebarSelectHTML(selected) {
            return Object.entries(rebarInfo).map(([no, info]) =>
                `<option value="${no}" ${no == selected ? 'selected' : ''}>${info.name}</option>`
            ).join('');
        }

        function renderOuterTable() {
            const tbody = document.getElementById('rcc-outer-body');
            tbody.innerHTML = rcColData.outer.map((pt, i) =>
                `<tr><td>${i + 1}</td><td><input type="number" value="${pt.x}" step="1" onchange="rcColData.outer[${i}].x=parseFloat(this.value)||0;drawRCColPreview()"></td><td><input type="number" value="${pt.y}" step="1" onchange="rcColData.outer[${i}].y=parseFloat(this.value)||0;drawRCColPreview()"></td></tr>`
            ).join('');
            drawRCColPreview();
        }

        function renderHollowTable() {
            const tbody = document.getElementById('rcc-hollow-body');
            tbody.innerHTML = rcColData.hollow.map((pt, i) =>
                `<tr><td>${i + 1}</td><td><input type="number" value="${pt.x}" step="1" onchange="rcColData.hollow[${i}].x=parseFloat(this.value)||0;drawRCColPreview()"></td><td><input type="number" value="${pt.y}" step="1" onchange="rcColData.hollow[${i}].y=parseFloat(this.value)||0;drawRCColPreview()"></td></tr>`
            ).join('');
            drawRCColPreview();
        }

        function onHollowPresetChange(type) {
            const paramsDiv = document.getElementById('rcc-hollow-params');
            const customDiv = document.getElementById('rcc-hollow-custom');
            if (type === 'none') {
                paramsDiv.style.display = 'none';
                paramsDiv.innerHTML = '';
                customDiv.style.display = 'none';
                rcColData.hollow = [];
                renderHollowTable();
                return;
            }
            if (type === 'custom') {
                paramsDiv.style.display = 'none';
                paramsDiv.innerHTML = '';
                customDiv.style.display = 'block';
                return;
            }
            customDiv.style.display = 'none';
            const paramDefs = {
                rect: [{ id: 'rcc-hp-Bh', label: 'Bh (寬)', val: 20 }, { id: 'rcc-hp-Hh', label: 'Hh (高)', val: 30 },
                { id: 'rcc-hp-Cx', label: 'Cx (中心X)', val: 25 }, { id: 'rcc-hp-Cy', label: 'Cy (中心Y)', val: 30 }],
                circle: [{ id: 'rcc-hp-Rh', label: 'Rh (半徑)', val: 15 },
                { id: 'rcc-hp-Cx', label: 'Cx (中心X)', val: 25 }, { id: 'rcc-hp-Cy', label: 'Cy (中心Y)', val: 30 }],
            };
            const defs = paramDefs[type] || [];
            paramsDiv.innerHTML = defs.map(d =>
                `<div class="form-group"><label>${d.label} <span>(cm)</span></label><input type="number" id="${d.id}" value="${d.val}" step="1" min="0" onchange="applyHollowShape('${type}')"></div>`
            ).join('');
            paramsDiv.style.display = 'grid';
            applyHollowShape(type);
        }

        function applyHollowShape(type) {
            switch (type) {
                case 'rect': {
                    const Bh = parseFloat(document.getElementById('rcc-hp-Bh').value) || 20;
                    const Hh = parseFloat(document.getElementById('rcc-hp-Hh').value) || 30;
                    const cx = parseFloat(document.getElementById('rcc-hp-Cx').value) || 25;
                    const cy = parseFloat(document.getElementById('rcc-hp-Cy').value) || 30;
                    rcColData.hollow = [
                        { x: cx - Bh / 2, y: cy - Hh / 2 }, { x: cx + Bh / 2, y: cy - Hh / 2 },
                        { x: cx + Bh / 2, y: cy + Hh / 2 }, { x: cx - Bh / 2, y: cy + Hh / 2 }
                    ];
                    break;
                }
                case 'circle': {
                    const rh = parseFloat(document.getElementById('rcc-hp-Rh').value) || 15;
                    const cx = parseFloat(document.getElementById('rcc-hp-Cx').value) || 25;
                    const cy = parseFloat(document.getElementById('rcc-hp-Cy').value) || 30;
                    const nPts = 24;
                    rcColData.hollow = [];
                    for (let i = 0; i < nPts; i++) {
                        const ang = (2 * Math.PI * i) / nPts;
                        rcColData.hollow.push({
                            x: parseFloat((cx + rh * Math.cos(ang)).toFixed(2)),
                            y: parseFloat((cy + rh * Math.sin(ang)).toFixed(2))
                        });
                    }
                    break;
                }
            }
            renderHollowTable();
        }

        function renderRebarTable() {
            const tbody = document.getElementById('rcc-rebar-body');
            tbody.innerHTML = rcColData.rebars.map((rb, i) => {
                const isCustom = rb.no === 0;
                const areaCell = isCustom
                    ? `<input type="number" value="${rb.area}" step="0.01" min="0" style="width:70px" onchange="rcColData.rebars[${i}].area=parseFloat(this.value)||0;drawRCColPreview()">`
                    : `<span>${rebarInfo[rb.no].area}</span>`;
                return `<tr><td>${i + 1}</td><td><input type="number" value="${rb.x}" step="0.5" onchange="rcColData.rebars[${i}].x=parseFloat(this.value)||0;drawRCColPreview()"></td><td><input type="number" value="${rb.y}" step="0.5" onchange="rcColData.rebars[${i}].y=parseFloat(this.value)||0;drawRCColPreview()"></td><td><select onchange="onRebarNoChange(${i},this.value)">${rebarSelectHTML(rb.no)}</select></td><td>${areaCell}</td></tr>`;
            }).join('');
            drawRCColPreview();
        }

        function onRebarNoChange(idx, val) {
            const no = parseInt(val);
            rcColData.rebars[idx].no = no;
            if (no !== 0) {
                rcColData.rebars[idx].area = rebarInfo[no].area;
            }
            renderRebarTable();
        }

        function addOuterPt() {
            const pts = rcColData.outer;
            rcColData.outer.push({ x: 0, y: 0 });
            renderOuterTable();
        }

        function removeOuterPt() {
            if (rcColData.outer.length > 0) {
                rcColData.outer.pop();
                renderOuterTable();
            }
        }

        function addHollowPt() {
            rcColData.hollow.push({ x: 0, y: 0 });
            renderHollowTable();
        }

        function removeHollowPt() {
            if (rcColData.hollow.length > 0) {
                rcColData.hollow.pop();
                renderHollowTable();
            }
        }

        function addRebar() {
            rcColData.rebars.push({ x: 0, y: 0, no: 8, area: rebarInfo[8].area });
            renderRebarTable();
        }

        function removeRebar() {
            if (rcColData.rebars.length > 0) {
                rcColData.rebars.pop();
                renderRebarTable();
            }
        }

        function updateCover() {
            const ic = parseFloat(document.getElementById('rcc-ic').value) || 4;
            const stirrupNo = parseInt(document.getElementById('rcc-stirrup').value) || 4;
            const db = rebarInfo[stirrupNo] ? rebarInfo[stirrupNo].dia : rebarInfo[4].dia;
            const cover = parseFloat((ic + db).toFixed(2));
            document.getElementById('rcc-cover').value = cover;
        }

        function onPresetChange(type) {
            const paramsDiv = document.getElementById('rcc-shape-params');
            if (!type) {
                paramsDiv.style.display = 'none';
                paramsDiv.innerHTML = '';
                return;
            }
            const paramDefs = {
                rect: [{ id: 'rcc-p-B', label: 'B (寬)', val: 50 }, { id: 'rcc-p-H', label: 'H (高)', val: 60 }],
                circle: [{ id: 'rcc-p-R', label: 'R (半徑)', val: 30 }],
                tshape: [{ id: 'rcc-p-Bf', label: 'Bf (翼寬)', val: 80 }, { id: 'rcc-p-tf', label: 'tf (翼厚)', val: 15 },
                { id: 'rcc-p-Bw', label: 'Bw (腹寬)', val: 30 }, { id: 'rcc-p-H', label: 'H (總高)', val: 60 }],
                lshape: [{ id: 'rcc-p-Bx', label: 'Bx (水平)', val: 60 }, { id: 'rcc-p-By', label: 'By (垂直)', val: 60 },
                { id: 'rcc-p-tx', label: 'tx (水平厚)', val: 20 }, { id: 'rcc-p-ty', label: 'ty (垂直厚)', val: 20 }],
            };
            const defs = paramDefs[type] || [];
            paramsDiv.innerHTML = defs.map(d =>
                `<div class="form-group"><label>${d.label} <span>(cm)</span></label><input type="number" id="${d.id}" value="${d.val}" step="1" min="1" onchange="applyPresetShape('${type}')"></div>`
            ).join('');
            paramsDiv.style.display = 'grid';
            applyPresetShape(type);
        }

        function applyPresetShape(type) {
            if (!type) return;
            rcColData.hollow = [];
            switch (type) {
                case 'rect': {
                    const B = parseFloat(document.getElementById('rcc-p-B').value) || 50;
                    const H = parseFloat(document.getElementById('rcc-p-H').value) || 60;
                    rcColData.outer = [
                        { x: 0, y: 0 }, { x: B, y: 0 },
                        { x: B, y: H }, { x: 0, y: H }
                    ];
                    break;
                }
                case 'circle': {
                    const r = parseFloat(document.getElementById('rcc-p-R').value) || 30;
                    const nPts = 24;
                    rcColData.outer = [];
                    for (let i = 0; i < nPts; i++) {
                        const ang = (2 * Math.PI * i) / nPts;
                        rcColData.outer.push({
                            x: parseFloat((r + r * Math.cos(ang)).toFixed(2)),
                            y: parseFloat((r + r * Math.sin(ang)).toFixed(2))
                        });
                    }
                    break;
                }
                case 'tshape': {
                    const Bf = parseFloat(document.getElementById('rcc-p-Bf').value) || 80;
                    const tf = parseFloat(document.getElementById('rcc-p-tf').value) || 15;
                    const Bw = parseFloat(document.getElementById('rcc-p-Bw').value) || 30;
                    const H = parseFloat(document.getElementById('rcc-p-H').value) || 60;
                    const x1 = (Bf - Bw) / 2;
                    const x2 = x1 + Bw;
                    rcColData.outer = [
                        { x: 0, y: 0 }, { x: Bf, y: 0 },
                        { x: Bf, y: tf }, { x: x2, y: tf },
                        { x: x2, y: H }, { x: x1, y: H },
                        { x: x1, y: tf }, { x: 0, y: tf }
                    ];
                    break;
                }
                case 'lshape': {
                    const Bx = parseFloat(document.getElementById('rcc-p-Bx').value) || 60;
                    const By = parseFloat(document.getElementById('rcc-p-By').value) || 60;
                    const tx = parseFloat(document.getElementById('rcc-p-tx').value) || 20;
                    const ty = parseFloat(document.getElementById('rcc-p-ty').value) || 20;
                    rcColData.outer = [
                        { x: 0, y: 0 }, { x: Bx, y: 0 },
                        { x: Bx, y: tx }, { x: ty, y: tx },
                        { x: ty, y: By }, { x: 0, y: By }
                    ];
                    break;
                }
            }
            renderOuterTable();
            renderHollowTable();
        }

        function calcBarAreaFromRhoG() {
            const rhoG = parseFloat(document.getElementById('rcc-rhoG').value);
            if (!rhoG || rhoG <= 0) return;
            const outer = rcColData.outer;
            if (outer.length < 3) return;

            const Ag = polyProps(outer).area;
            const hollowPoly = rcColData.hollow || [];
            const Ah = hollowPoly.length >= 3 ? polyProps(hollowPoly).area : 0;
            const Anet = Ag - Ah;
            const Ast = rhoG / 100 * Anet;

            // 先以暫定面積排列一次，取得實際根數
            autoArrangeRebar();
            const nBars = rcColData.rebars.length;
            if (nBars < 1) return;

            // 以實際根數反算每支面積，更新所有鋼筋
            const barArea = Ast / nBars;
            document.getElementById('rcc-barArea').value = parseFloat(barArea.toFixed(4));
            rcColData.rebars.forEach(rb => { rb.area = barArea; });
            renderRebarTable();
        }

        function autoArrangeRebar() {
            const pts = rcColData.outer;
            if (pts.length < 3) return;
            const cover = parseFloat(document.getElementById('rcc-cover').value) || 4;
            const spacing = parseFloat(document.getElementById('rcc-spacing').value) || 15;
            const barArea = parseFloat(document.getElementById('rcc-barArea').value) || 5.07;

            // Inward offset polygon: move each edge inward by cover along its normal,
            // then intersect adjacent offset edges to get new vertices.
            const n = pts.length;

            // Compute inward unit normal for each edge (assumes CCW winding; auto-detect)
            // Check winding via signed area
            let signedArea2 = 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                signedArea2 += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
            }
            const windingSign = signedArea2 >= 0 ? 1 : -1; // +1 if CCW, -1 if CW

            // For each edge i→i+1, compute offset line (point + direction)
            const edges = [];
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const ex = pts[j].x - pts[i].x;
                const ey = pts[j].y - pts[i].y;
                const len = Math.sqrt(ex * ex + ey * ey);
                if (len === 0) { edges.push(null); continue; }
                // Inward normal: for CCW polygon, inward normal of edge (ex,ey) is (-ey,ex) normalized
                const nx = windingSign * (-ey) / len;
                const ny = windingSign * ex / len;
                // Offset line: shift edge start/end by cover * normal
                edges.push({
                    px: pts[i].x + nx * cover, py: pts[i].y + ny * cover,
                    dx: ex, dy: ey
                });
            }

            // Intersect adjacent offset edges to get offset polygon vertices
            function lineIntersect(e1, e2) {
                // e1: point (px,py) + t*(dx,dy), e2: point (px,py) + s*(dx,dy)
                const det = e1.dx * e2.dy - e1.dy * e2.dx;
                if (Math.abs(det) < 1e-10) return null; // parallel
                const t = ((e2.px - e1.px) * e2.dy - (e2.py - e1.py) * e2.dx) / det;
                return { x: e1.px + t * e1.dx, y: e1.py + t * e1.dy };
            }

            const offsetPts = [];
            for (let i = 0; i < n; i++) {
                const prev = (i - 1 + n) % n;
                const e1 = edges[prev], e2 = edges[i];
                if (!e1 || !e2) { offsetPts.push({ x: pts[i].x, y: pts[i].y }); continue; }
                const pt = lineIntersect(e1, e2);
                if (!pt) { offsetPts.push({ x: pts[i].x, y: pts[i].y }); continue; }
                offsetPts.push({
                    x: parseFloat(pt.x.toFixed(2)),
                    y: parseFloat(pt.y.toFixed(2))
                });
            }

            // Place rebars at offset vertices + midpoints of longer edges
            rcColData.rebars = [];
            for (let i = 0; i < offsetPts.length; i++) {
                rcColData.rebars.push({ x: offsetPts[i].x, y: offsetPts[i].y, no: 0, area: barArea });
                const j = (i + 1) % offsetPts.length;
                const dx = offsetPts[j].x - offsetPts[i].x;
                const dy = offsetPts[j].y - offsetPts[i].y;
                const edgeLen = Math.sqrt(dx * dx + dy * dy);
                const nSeg = Math.floor(edgeLen / spacing);
                for (let k = 1; k < nSeg; k++) {
                    rcColData.rebars.push({
                        x: parseFloat((offsetPts[i].x + dx * k / nSeg).toFixed(2)),
                        y: parseFloat((offsetPts[i].y + dy * k / nSeg).toFixed(2)),
                        no: 0,
                        area: barArea
                    });
                }
            }
            renderRebarTable();
        }

        function drawRCColPreview() {
            const svg = document.getElementById('rcc-svg');
            const outer = rcColData.outer;
            const hollow = rcColData.hollow;
            const rebars = rcColData.rebars;

            if (outer.length < 3) {
                svg.innerHTML = '<text x="200" y="200" text-anchor="middle" fill="#94a3b8" font-size="14">請輸入至少 3 個外輪廓頂點</text>';
                return;
            }

            // Find bounding box
            let allPts = [...outer];
            if (hollow.length > 0) allPts = allPts.concat(hollow);
            rebars.forEach(r => allPts.push({ x: r.x, y: r.y }));

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            allPts.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
            });

            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const svgW = 380, svgH = 380;
            const margin = 30;
            const drawW = svgW - 2 * margin;
            const drawH = svgH - 2 * margin;
            const scale = Math.min(drawW / rangeX, drawH / rangeY);
            const offX = margin + (drawW - rangeX * scale) / 2;
            const offY = margin + (drawH - rangeY * scale) / 2;

            // Transform: flip Y so Y-up
            function tx(x) { return offX + (x - minX) * scale; }
            function ty(y) { return offY + (maxY - y) * scale; }

            let html = '';

            // Grid lines
            html += '<rect x="0" y="0" width="400" height="400" fill="#fafbfc"/>';

            // Outer polygon
            const outerPts = outer.map(p => tx(p.x) + ',' + ty(p.y)).join(' ');
            html += `<polygon points="${outerPts}" fill="#e0e7ff" stroke="#2563eb" stroke-width="2"/>`;

            // Hollow polygon
            if (hollow.length >= 3) {
                const hollowPts = hollow.map(p => tx(p.x) + ',' + ty(p.y)).join(' ');
                html += `<polygon points="${hollowPts}" fill="#fafbfc" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="4"/>`;
            }

            // Vertex labels for outer
            outer.forEach((p, i) => {
                const sx = tx(p.x), sy = ty(p.y);
                html += `<circle cx="${sx}" cy="${sy}" r="3" fill="#2563eb"/>`;
                html += `<text x="${sx + 5}" y="${sy - 5}" fill="#2563eb" font-size="9">${i + 1}</text>`;
            });

            // Rebars - circle size proportional to actual area
            rebars.forEach((rb, i) => {
                const sx = tx(rb.x), sy = ty(rb.y);
                const area = rb.area || (rebarInfo[rb.no] || rebarInfo[8]).area;
                const dia = area > 0 ? Math.sqrt(4 * area / Math.PI) : 1;
                const r = Math.max(3, dia * scale / 2);
                html += `<circle cx="${sx}" cy="${sy}" r="${Math.min(r, 8)}" fill="#ef4444" stroke="#b91c1c" stroke-width="1"/>`;
                const label = rb.no === 0 ? '自訂' : (rebarInfo[rb.no] || rebarInfo[8]).name.split(' ')[0];
                html += `<text x="${sx + 6}" y="${sy + 3}" fill="#b91c1c" font-size="8">${label}</text>`;
            });

            // 塑性中心與方位角
            if (rcColData.pcX !== null && rcColData.pcY !== null) {
                const pcSx = tx(rcColData.pcX), pcSy = ty(rcColData.pcY);
                // 塑性中心十字標記
                html += `<line x1="${pcSx - 6}" y1="${pcSy}" x2="${pcSx + 6}" y2="${pcSy}" stroke="#16a34a" stroke-width="2"/>`;
                html += `<line x1="${pcSx}" y1="${pcSy - 6}" x2="${pcSx}" y2="${pcSy + 6}" stroke="#16a34a" stroke-width="2"/>`;
                html += `<circle cx="${pcSx}" cy="${pcSy}" r="4" fill="none" stroke="#16a34a" stroke-width="1.5"/>`;
                html += `<text x="${pcSx + 8}" y="${pcSy - 8}" fill="#16a34a" font-size="9" font-weight="bold">PC</text>`;

                // 方位角箭頭
                if (rcColData.alpha !== null) {
                    const alphaRad = rcColData.alpha * Math.PI / 180;
                    const arrowLen = 40;
                    // SVG Y 軸向下, 所以 dy 取負
                    const ax = pcSx + arrowLen * Math.cos(alphaRad);
                    const ay = pcSy - arrowLen * Math.sin(alphaRad);
                    html += `<line x1="${pcSx}" y1="${pcSy}" x2="${ax}" y2="${ay}" stroke="#f59e0b" stroke-width="2.5" marker-end="url(#arrowAlpha)"/>`;
                    // 箭頭 marker 定義
                    html = `<defs><marker id="arrowAlpha" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6 Z" fill="#f59e0b"/></marker></defs>` + html;
                    // 角度標示
                    const labelX = pcSx + (arrowLen + 8) * Math.cos(alphaRad);
                    const labelY = pcSy - (arrowLen + 8) * Math.sin(alphaRad);
                    html += `<text x="${labelX}" y="${labelY}" fill="#f59e0b" font-size="10" font-weight="bold">α=${rcColData.alpha.toFixed(1)}°</text>`;
                }
            }

            // Axes label
            html += '<text x="10" y="395" fill="#94a3b8" font-size="10">單位: cm | Y↑ X→</text>';

            // Dimension labels
            html += `<text x="${tx(minX)}" y="${ty(minY) + 15}" fill="#64748b" font-size="9">(${minX},${minY})</text>`;
            html += `<text x="${tx(maxX) - 30}" y="${ty(maxY) - 5}" fill="#64748b" font-size="9">(${maxX},${maxY})</text>`;

            svg.innerHTML = html;
        }

        // 多邊形面積與重心 (Shoelace formula)
        function polyProps(pts) {
            const n = pts.length;
            if (n < 3) return { area: 0, cx: 0, cy: 0 };
            let A = 0, Sx = 0, Sy = 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const cross = pts[i].x * pts[j].y - pts[j].x * pts[i].y;
                A += cross;
                Sx += (pts[i].x + pts[j].x) * cross;
                Sy += (pts[i].y + pts[j].y) * cross;
            }
            A /= 2; // signed area
            const area = Math.abs(A);
            if (area === 0) return { area: 0, cx: 0, cy: 0 };
            return { area, cx: Sx / (6 * A), cy: Sy / (6 * A) };
        }

        // ===== P-M Interaction Curve =====

        // Sutherland-Hodgman half-plane clip
        // Keeps points on the side where dot(pt - linePoint, lineNormal) >= 0
        function clipPolygonByLine(polygon, linePoint, lineNormal) {
            if (polygon.length === 0) return [];
            const output = [];
            const n = polygon.length;
            for (let i = 0; i < n; i++) {
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];
                const dCurr = (curr.x - linePoint.x) * lineNormal.x + (curr.y - linePoint.y) * lineNormal.y;
                const dNext = (next.x - linePoint.x) * lineNormal.x + (next.y - linePoint.y) * lineNormal.y;
                if (dCurr >= 0) {
                    output.push(curr);
                    if (dNext < 0) {
                        const t = dCurr / (dCurr - dNext);
                        output.push({ x: curr.x + t * (next.x - curr.x), y: curr.y + t * (next.y - curr.y) });
                    }
                } else if (dNext >= 0) {
                    const t = dCurr / (dCurr - dNext);
                    output.push({ x: curr.x + t * (next.x - curr.x), y: curr.y + t * (next.y - curr.y) });
                }
            }
            return output;
        }

        // Compute polygon area and centroid (signed area, returns absolute)
        function polyAreaCentroid(pts) {
            const n = pts.length;
            if (n < 3) return { area: 0, cx: 0, cy: 0 };
            let A = 0, Sx = 0, Sy = 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const cross = pts[i].x * pts[j].y - pts[j].x * pts[i].y;
                A += cross;
                Sx += (pts[i].x + pts[j].x) * cross;
                Sy += (pts[i].y + pts[j].y) * cross;
            }
            A /= 2;
            const area = Math.abs(A);
            if (area < 1e-10) return { area: 0, cx: 0, cy: 0 };
            return { area, cx: Sx / (6 * A), cy: Sy / (6 * A) };
        }

        // Compute one P-M point for a given neutral axis depth c
        // alpha: angle in radians from X-axis (direction of compression)
        // All units: cm, kgf/cm²
        function computePMPoint(c, outerPoly, hollowPoly, rebars, fc, fy, Es, beta1, alphaRad, extremeCompDist, totalDepth, pcAlpha) {
            const ecu = 0.003;
            const a = beta1 * c;

            // Direction unit vector (compression side)
            const cosA = Math.cos(alphaRad);
            const sinA = Math.sin(alphaRad);

            // The neutral axis line is at distance (extremeCompDist - c) from origin along alpha direction
            const naLineDist = extremeCompDist - c;
            const sbLineDist = extremeCompDist - a;

            // Clip polygon: keep region where projected coord >= sbLineDist (compression block)
            const sbPoint = { x: sbLineDist * cosA, y: sbLineDist * sinA };
            const sbNormal = { x: cosA, y: sinA };

            // Clip outer polygon by stress block line
            let compPoly = clipPolygonByLine(outerPoly, sbPoint, sbNormal);
            const compOuter = polyAreaCentroid(compPoly);

            // Clip hollow polygon by same line, subtract
            let compHollowArea = 0, compHollowCx = 0, compHollowCy = 0;
            if (hollowPoly.length >= 3) {
                const compHollow = clipPolygonByLine(hollowPoly, sbPoint, sbNormal);
                const hProps = polyAreaCentroid(compHollow);
                compHollowArea = hProps.area;
                compHollowCx = hProps.cx;
                compHollowCy = hProps.cy;
            }

            const Acomp = compOuter.area - compHollowArea;
            // Concrete compression force: 0.85 * f'c * Acomp
            const Cc = 0.85 * fc * Acomp;

            // Moment of concrete force about plastic centroid
            // Mnx_conc = Cc * (Cy - pcY)  (Moment about X axis)
            // Mny_conc = Cc * (Cx - pcX)  (Moment about Y axis)
            // Note: In standard structural analysis:
            // Mx is moment about X-axis. Positive Mx causes compression on top (positive Y)?
            // My is moment about Y-axis. Positive My causes compression on right (positive X)?
            // Our coordinate: Y-up, X-right.
            // Force is compression (positive P).
            // Arm y = (Cy - pcY). Positive y arm -> Force at top -> creates Moment about X.
            // If Force is compression (pushing into page/column), and it's at +y:
            // It creates a "Hogging" moment? Or typical column notation?
            // Let's stick to simple cross product logic: M = r x F.
            // But this is 2D calculation of capacity.
            // Let's calculation (Force * Distance).
            // Mnx = Force * (y - pcY).
            // Mny = Force * (x - pcX).

            let Mnx_conc = 0, Mny_conc = 0;
            if (Acomp > 0) {
                const compCx = (compOuter.area * compOuter.cx - compHollowArea * compHollowCx) / Acomp;
                const compCy = (compOuter.area * compOuter.cy - compHollowArea * compHollowCy) / Acomp;
                Mnx_conc = Cc * (compCy - pcAlpha.y);
                Mny_conc = Cc * (compCx - pcAlpha.x);
            }

            // Steel forces
            let Fs_total = 0, Mnx_steel = 0, Mny_steel = 0;
            let minEpsTension = Infinity; // track most tensile strain (most negative projected dist)
            rebars.forEach(rb => {
                const asi = rb.area;
                // Projected distance of this rebar along alpha direction
                const di_proj = rb.x * cosA + rb.y * sinA;
                // Distance from extreme compression fiber
                const di_from_top = extremeCompDist - di_proj;
                // Strain: positive = compression
                const epsi = ecu * (c - di_from_top) / c;
                // Steel stress (capped at fy)
                let sigma = Es * epsi;
                if (sigma > fy) sigma = fy;
                if (sigma < -fy) sigma = -fy;
                // If rebar is in compression zone, subtract concrete stress already counted
                let sigmaNet = sigma;
                if (di_from_top <= a && di_from_top >= 0) {
                    sigmaNet = sigma - 0.85 * fc;
                }
                const fi = sigmaNet * asi;
                Fs_total += fi;

                // Moment about Plastic Centroid
                Mnx_steel += fi * (rb.y - pcAlpha.y);
                Mny_steel += fi * (rb.x - pcAlpha.x);

                // Track extreme tension strain
                if (epsi < minEpsTension) minEpsTension = epsi;
            });

            const Pn = Cc + Fs_total; // positive = compression
            const Mn_x = Mnx_conc + Mnx_steel;
            const Mn_y = Mny_conc + Mny_steel;
            // Scalar Mn magnitude (projected onto alpha axis, for legacy 2D check)
            // Mn_proj = Mn_x * sinA + Mn_y * cosA? No.
            // With Mnx = F*dy, Mny = F*dx.
            // Vector M = (Mnx, My)? No, usually (Mx, My) vectors are roughly perpendicular to arms.
            // Moment vector M is (Mx, My). 
            // Mx vector is along X axis. Calculated from y-arm.
            // My vector is along Y axis. Calculated from x-arm.
            // M_scalar_proj = component along alpha-normal?

            // For 2D legacy compatibility, let's keep the projected calculation
            // But actually, we can just return Mnx, Mny and let caller decide.
            // Let's compute Mn_proj for phiMn calculation in 2D curve.
            const Mn_proj = Mn_x * sinA + Mn_y * cosA;
            // Wait, if Alpha is 0 (X-axis compression), arm is X (Mny).
            // sin(0)=0. cos(0)=1. Mn_proj = Mn_y. Correct.
            // If Alpha is 90 (Y-axis compression), arm is Y (Mnx).
            // sin(90)=1. Mn_proj = Mn_x. Correct.

            // phi factor based on extreme tension strain
            const epsT = -minEpsTension; // tension is positive now
            const epsY = fy / Es;
            let phi;
            if (epsT <= epsY) {
                phi = 0.65; // compression controlled
            } else if (epsT >= 0.005) {
                phi = 0.9; // tension controlled
            } else {
                phi = 0.65 + 0.25 * (epsT - epsY) / (0.005 - epsY);
            }

            // Cs/Ts = sum of compression/tension steel forces
            let Cs = 0, Ts = 0;
            rebars.forEach(rb => {
                const asi = rb.area;
                const di_proj = rb.x * cosA + rb.y * sinA;
                const di_from_top = extremeCompDist - di_proj;
                const epsi = ecu * (c - di_from_top) / c;
                let sigma = Es * epsi;
                if (sigma > fy) sigma = fy;
                if (sigma < -fy) sigma = -fy;
                let sigmaNet = sigma;
                if (di_from_top <= a && di_from_top >= 0) sigmaNet = sigma - 0.85 * fc;
                const fi = sigmaNet * asi;
                if (fi < 0) Ts += fi;
                else Cs += fi;
            });

            return { Pn, Mnx: Mn_x, Mny: Mn_y, Mn: Math.abs(Mn_proj), phi, epsT, Cc, Cs, Ts };
        }

        function generatePMCurve(outerPoly, hollowPoly, rebars, fc, fy, Es, pcX, pcY, alphaRad) {
            // Beta1
            let beta1;
            if (fc <= 280) beta1 = 0.85;
            else if (fc >= 560) beta1 = 0.65;
            else beta1 = 0.85 - 0.05 * (fc - 280) / 70;

            const cosA = Math.cos(alphaRad);
            const sinA = Math.sin(alphaRad);

            // Project all vertices onto alpha direction
            let allPts = [...outerPoly];
            const projections = allPts.map(p => p.x * cosA + p.y * sinA);
            const extremeCompDist = Math.max(...projections);
            const extremeTensDist = Math.min(...projections);
            const totalDepth = extremeCompDist - extremeTensDist;

            const pcAlpha = { x: pcX, y: pcY };

            // Pure compression: Po
            const outerProps = polyAreaCentroid(outerPoly);
            const hollowProps = polyAreaCentroid(hollowPoly);
            const Anet = outerProps.area - hollowProps.area;
            let totalAs = 0;
            rebars.forEach(rb => totalAs += rb.area || (rebarInfo[rb.no] || rebarInfo[8]).area);
            const Ac = Anet - totalAs; // 混凝土淨面積
            const Po = 0.85 * fc * Ac + fy * totalAs;
            const phiPo_max = 0.80 * 0.65 * Po; // ACI max for tied columns

            // Compute exact balanced cb
            // d = distance from extreme compression fiber to farthest tension rebar
            const epsY = fy / Es;
            let dMax = 0;
            rebars.forEach(rb => {
                const di_from_top = extremeCompDist - (rb.x * cosA + rb.y * sinA);
                if (di_from_top > dMax) dMax = di_from_top;
            });
            const cb = dMax > 0 ? dMax * 0.003 / (0.003 + epsY) : totalDepth * 0.5;

            // Sweep c from small to large
            const pmPoints = [];
            const cMin = totalDepth * 0.01;
            const cMax = totalDepth * 10;

            // Use logarithmic spacing for better resolution near small c values
            const numPts = 80;
            const logMin = Math.log(cMin);
            const logMax = Math.log(cMax);

            // Collect c values and insert exact cb
            const cValues = [];
            for (let i = 0; i <= numPts; i++) {
                const t = i / numPts;
                cValues.push(Math.exp(logMin + t * (logMax - logMin)));
            }
            // Insert cb if within range
            let balanceIdx = -1;
            if (cb >= cMin && cb <= cMax) {
                cValues.push(cb);
                cValues.sort((a, b) => a - b);
            }

            cValues.forEach((c, i) => {
                const pt = computePMPoint(c, outerPoly, hollowPoly, rebars, fc, fy, Es, beta1, alphaRad, extremeCompDist, totalDepth, pcAlpha);
                if (Math.abs(c - cb) < 1e-6) balanceIdx = i;
                pmPoints.push({
                    c,
                    Pn: pt.Pn,
                    Mn: pt.Mn,
                    Mnx: pt.Mnx,
                    Mny: pt.Mny,
                    phi: pt.phi,
                    phiPn: pt.phi * pt.Pn,
                    phiMn: pt.phi * pt.Mn,
                    phiMnx: pt.phi * pt.Mnx,
                    Cc: pt.Cc,
                    Cs: pt.Cs,
                    Ts: pt.Ts,
                    phiMny: pt.phi * pt.Mny,
                    epsT: pt.epsT
                });
            });

            // Fallback if cb was out of range
            if (balanceIdx < 0) {
                let minDiff = Infinity;
                pmPoints.forEach((pt, i) => {
                    const diff = Math.abs(pt.epsT - epsY);
                    if (diff < minDiff) { minDiff = diff; balanceIdx = i; }
                });
            }

            // Apply ACI max axial force cap
            pmPoints.forEach(pt => {
                if (pt.phiPn > phiPo_max) {
                    pt.phiPn = phiPo_max;
                }
            });

            // Find pure bending point (Pn ≈ 0), interpolate
            let pureBendIdx = 0;
            let minAbsP = Infinity;
            pmPoints.forEach((pt, i) => {
                if (Math.abs(pt.Pn) < minAbsP) { minAbsP = Math.abs(pt.Pn); pureBendIdx = i; }
            });

            // Convert to tf and tf·m
            const curve = pmPoints.map(pt => ({
                phiPn_tf: pt.phiPn / 1000,
                phiMn_tfm: pt.phiMn / 100000,
                phiMnx_tfm: pt.phiMnx / 100000,
                phiMny_tfm: pt.phiMny / 100000,
                Pn_tf: pt.Pn / 1000,
                Mn_tfm: pt.Mn / 100000,
                Mnx_tfm: pt.Mnx / 100000, // Nominal Mnx in tf·m
                Mny_tfm: pt.Mny / 100000, // Nominal Mny in tf·m
                phi: pt.phi,
                epsT: pt.epsT,
                c: pt.c,
                Cc_tf: pt.Cc / 1000,
                Cs_tf: pt.Cs / 1000,
                Ts_tf: pt.Ts / 1000
            }));

            return {
                curve,
                Po_tf: Po / 1000,
                phiPo_max_tf: phiPo_max / 1000,
                balanceIdx,
                pureBendIdx,
                beta1,
                cb
            };
        }

        function drawPMChart(pmData, loadPoints) {
            const container = document.getElementById('pm-chart-container');
            const svg = document.getElementById('pm-chart-svg');
            const statusDiv = document.getElementById('pm-status');
            container.style.display = 'block';

            const curve = pmData.curve;
            if (curve.length < 2) {
                svg.innerHTML = '<text x="260" y="240" text-anchor="middle" fill="#94a3b8">資料不足</text>';
                return;
            }

            // Chart dimensions
            const W = 520, H = 480;
            const margin = { top: 30, right: 30, bottom: 50, left: 70 };
            const plotW = W - margin.left - margin.right;
            const plotH = H - margin.top - margin.bottom;

            // Find data range (include both φPn-φMn and Pn-Mn)
            let maxM = 0, maxP = 0, minP = 0;
            curve.forEach(pt => {
                if (pt.phiMn_tfm > maxM) maxM = pt.phiMn_tfm;
                if (pt.Mn_tfm > maxM) maxM = pt.Mn_tfm;
                if (pt.phiPn_tf > maxP) maxP = pt.phiPn_tf;
                if (pt.Pn_tf > maxP) maxP = pt.Pn_tf;
                if (pt.phiPn_tf < minP) minP = pt.phiPn_tf;
                if (pt.Pn_tf < minP) minP = pt.Pn_tf;
            });
            // Include all design points
            loadPoints.forEach(lp => {
                if (lp.Mu_tfm > maxM) maxM = lp.Mu_tfm;
                if (lp.Pu_tf > maxP) maxP = lp.Pu_tf;
                if (lp.Pu_tf < minP) minP = lp.Pu_tf;
            });

            // Add padding
            maxM *= 1.15;
            maxP *= 1.15;
            minP = Math.min(minP * 1.15, 0);

            if (maxM < 0.001) maxM = 1;
            if (maxP < 0.001) maxP = 1;
            const rangeP = maxP - minP;

            // Scale functions
            function sx(m) { return margin.left + (m / maxM) * plotW; }
            function sy(p) { return margin.top + plotH - ((p - minP) / rangeP) * plotH; }

            let html = '';

            // Background
            html += `<rect x="0" y="0" width="${W}" height="${H}" fill="#fafbfc"/>`;

            // Grid lines
            const nGridX = 5, nGridY = 6;
            for (let i = 0; i <= nGridX; i++) {
                const xv = (maxM * i / nGridX);
                const x = sx(xv);
                html += `<line x1="${x}" y1="${margin.top}" x2="${x}" y2="${margin.top + plotH}" stroke="#e2e8f0" stroke-width="0.5"/>`;
                html += `<text x="${x}" y="${margin.top + plotH + 18}" text-anchor="middle" fill="#64748b" font-size="10">${xv.toFixed(1)}</text>`;
            }
            for (let i = 0; i <= nGridY; i++) {
                const pv = minP + rangeP * i / nGridY;
                const y = sy(pv);
                html += `<line x1="${margin.left}" y1="${y}" x2="${margin.left + plotW}" y2="${y}" stroke="#e2e8f0" stroke-width="0.5"/>`;
                html += `<text x="${margin.left - 8}" y="${y + 4}" text-anchor="end" fill="#64748b" font-size="10">${pv.toFixed(0)}</text>`;
            }

            // Axes
            html += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotH}" stroke="#334155" stroke-width="1.5"/>`;
            html += `<line x1="${margin.left}" y1="${margin.top + plotH}" x2="${margin.left + plotW}" y2="${margin.top + plotH}" stroke="#334155" stroke-width="1.5"/>`;
            // Zero line if minP < 0
            if (minP < 0) {
                const y0 = sy(0);
                html += `<line x1="${margin.left}" y1="${y0}" x2="${margin.left + plotW}" y2="${y0}" stroke="#94a3b8" stroke-width="1" stroke-dasharray="4"/>`;
            }

            // Axis labels
            html += `<text x="${margin.left + plotW / 2}" y="${H - 5}" text-anchor="middle" fill="#334155" font-size="12" font-weight="600">M (tf·m)</text>`;
            html += `<text x="15" y="${margin.top + plotH / 2}" text-anchor="middle" fill="#334155" font-size="12" font-weight="600" transform="rotate(-90,15,${margin.top + plotH / 2})">P (tf)</text>`;

            // P-M curve
            let pathD = '';
            curve.forEach((pt, i) => {
                const x = sx(pt.phiMn_tfm);
                const y = sy(pt.phiPn_tf);
                pathD += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1) + ' ';
            });
            html += `<path d="${pathD}" fill="none" stroke="#2563eb" stroke-width="2.5" stroke-linejoin="round"/>`;

            // Fill area (safe zone)
            let fillD = pathD;
            fillD += `L${sx(0).toFixed(1)},${sy(curve[curve.length - 1].phiPn_tf).toFixed(1)} `;
            fillD += `L${sx(0).toFixed(1)},${sy(curve[0].phiPn_tf).toFixed(1)} Z`;
            html += `<path d="${fillD}" fill="#2563eb" opacity="0.08"/>`;

            // Pn-Mn nominal curve (dashed)
            let nomPathD = '';
            const Po_cap = pmData.Po_tf;
            curve.forEach((pt, i) => {
                const pn = Math.min(pt.Pn_tf, Po_cap);
                const x = sx(pt.Mn_tfm);
                const y = sy(pn);
                nomPathD += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1) + ' ';
            });
            html += `<path d="${nomPathD}" fill="none" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6,3" stroke-linejoin="round"/>`;

            // Special points markers
            const topPt = curve[curve.length - 1];
            html += `<circle cx="${sx(topPt.phiMn_tfm)}" cy="${sy(topPt.phiPn_tf)}" r="4" fill="#16a34a" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${sx(topPt.phiMn_tfm) + 6}" y="${sy(topPt.phiPn_tf) + 4}" fill="#16a34a" font-size="9" font-weight="600">φPo,max</text>`;

            const balPt = curve[pmData.balanceIdx];
            html += `<circle cx="${sx(balPt.phiMn_tfm)}" cy="${sy(balPt.phiPn_tf)}" r="4" fill="#f59e0b" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${sx(balPt.phiMn_tfm) + 6}" y="${sy(balPt.phiPn_tf) - 6}" fill="#f59e0b" font-size="9" font-weight="600">平衡點</text>`;

            const pbPt = curve[pmData.pureBendIdx];
            html += `<circle cx="${sx(pbPt.phiMn_tfm)}" cy="${sy(pbPt.phiPn_tf)}" r="4" fill="#8b5cf6" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${sx(pbPt.phiMn_tfm) + 6}" y="${sy(pbPt.phiPn_tf) + 12}" fill="#8b5cf6" font-size="9" font-weight="600">純彎</text>`;

            // Design points (multiple load cases)
            loadPoints.forEach(lp => {
                const dpx = sx(lp.Mu_tfm), dpy = sy(lp.Pu_tf);
                const color = lp.safe ? '#16a34a' : '#ef4444';
                html += `<circle cx="${dpx}" cy="${dpy}" r="6" fill="${color}" stroke="white" stroke-width="2"/>`;
                html += `<text x="${dpx + 8}" y="${dpy - 4}" fill="${color}" font-size="9" font-weight="700">#${lp.idx}</text>`;
            });

            // Legend
            const lgX = margin.left + plotW - 130, lgY = margin.top + 10;
            html += `<rect x="${lgX}" y="${lgY}" width="135" height="75" rx="4" fill="white" stroke="#e2e8f0" stroke-width="1"/>`;
            html += `<line x1="${lgX + 8}" y1="${lgY + 15}" x2="${lgX + 30}" y2="${lgY + 15}" stroke="#2563eb" stroke-width="2.5"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 19}" fill="#334155" font-size="10">φPn-φMn（設計）</text>`;
            html += `<line x1="${lgX + 8}" y1="${lgY + 32}" x2="${lgX + 30}" y2="${lgY + 32}" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6,3"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 36}" fill="#334155" font-size="10">Pn-Mn（標稱）</text>`;
            html += `<circle cx="${lgX + 19}" cy="${lgY + 49}" r="4" fill="#16a34a" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 53}" fill="#334155" font-size="10">安全</text>`;
            html += `<circle cx="${lgX + 19}" cy="${lgY + 66}" r="4" fill="#ef4444" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 70}" fill="#334155" font-size="10">不安全</text>`;

            // Title
            html += `<text x="${W / 2}" y="18" text-anchor="middle" fill="#334155" font-size="13" font-weight="700">P-M 交互作用曲線 (α=${(rcColData.alpha || 0).toFixed(1)}°)</text>`;

            svg.innerHTML = html;

            // Status message
            const safeCount = loadPoints.filter(lp => lp.safe).length;
            const totalCount = loadPoints.length;
            if (safeCount === totalCount) {
                statusDiv.innerHTML = `<span style="color:#16a34a;">✓ 全部安全：${totalCount} 筆載重組合皆位於 P-M 曲線內</span>`;
            } else {
                statusDiv.innerHTML = `<span style="color:#ef4444;">✗ ${totalCount - safeCount}/${totalCount} 筆載重不安全：設計點位於 P-M 曲線外</span>`;
            }
        }

        function drawPMChart2D(surface, loadPoints, alphaDeg) {
            const container = document.getElementById('pm-chart-2d-container');
            const svg = document.getElementById('pm-chart-2d-svg');
            const statusDiv = document.getElementById('pm-2d-status');
            container.style.display = 'block';

            const curve = interpolateSurfaceAtAngle(surface, alphaDeg);
            if (!curve || curve.length < 2) {
                svg.innerHTML = '<text x="260" y="240" text-anchor="middle" fill="#94a3b8">資料不足</text>';
                return;
            }

            // Find balance point (max phiMn_tfm) and pure bending (phiPn closest to 0)
            let balanceIdx = 0, pureBendIdx = 0;
            let maxMn = 0, minAbsP = Infinity;
            curve.forEach((pt, i) => {
                if (pt.phiMn_tfm > maxMn) { maxMn = pt.phiMn_tfm; balanceIdx = i; }
                if (Math.abs(pt.phiPn_tf) < minAbsP) { minAbsP = Math.abs(pt.phiPn_tf); pureBendIdx = i; }
            });

            // Chart dimensions
            const W = 520, H = 480;
            const margin = { top: 30, right: 30, bottom: 50, left: 70 };
            const plotW = W - margin.left - margin.right;
            const plotH = H - margin.top - margin.bottom;

            // Data range
            let maxM = 0, maxP = 0, minP = 0;
            curve.forEach(pt => {
                if (pt.phiMn_tfm > maxM) maxM = pt.phiMn_tfm;
                if (pt.Mn_tfm > maxM) maxM = pt.Mn_tfm;
                if (pt.phiPn_tf > maxP) maxP = pt.phiPn_tf;
                if (pt.Pn_tf > maxP) maxP = pt.Pn_tf;
                if (pt.phiPn_tf < minP) minP = pt.phiPn_tf;
                if (pt.Pn_tf < minP) minP = pt.Pn_tf;
            });
            loadPoints.forEach(lp => {
                if (lp.Mu_tfm > maxM) maxM = lp.Mu_tfm;
                if (lp.Pu_tf > maxP) maxP = lp.Pu_tf;
                if (lp.Pu_tf < minP) minP = lp.Pu_tf;
            });

            maxM *= 1.15; maxP *= 1.15;
            minP = Math.min(minP * 1.15, 0);
            if (maxM < 0.001) maxM = 1;
            if (maxP < 0.001) maxP = 1;
            const rangeP = maxP - minP;

            function sx(m) { return margin.left + (m / maxM) * plotW; }
            function sy(p) { return margin.top + plotH - ((p - minP) / rangeP) * plotH; }

            let html = '';
            html += `<rect x="0" y="0" width="${W}" height="${H}" fill="#fafbfc"/>`;

            // Grid
            const nGridX = 5, nGridY = 6;
            for (let i = 0; i <= nGridX; i++) {
                const xv = maxM * i / nGridX, x = sx(xv);
                html += `<line x1="${x}" y1="${margin.top}" x2="${x}" y2="${margin.top + plotH}" stroke="#e2e8f0" stroke-width="0.5"/>`;
                html += `<text x="${x}" y="${margin.top + plotH + 18}" text-anchor="middle" fill="#64748b" font-size="10">${xv.toFixed(1)}</text>`;
            }
            for (let i = 0; i <= nGridY; i++) {
                const pv = minP + rangeP * i / nGridY, y = sy(pv);
                html += `<line x1="${margin.left}" y1="${y}" x2="${margin.left + plotW}" y2="${y}" stroke="#e2e8f0" stroke-width="0.5"/>`;
                html += `<text x="${margin.left - 8}" y="${y + 4}" text-anchor="end" fill="#64748b" font-size="10">${pv.toFixed(0)}</text>`;
            }

            // Axes
            html += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotH}" stroke="#334155" stroke-width="1.5"/>`;
            html += `<line x1="${margin.left}" y1="${margin.top + plotH}" x2="${margin.left + plotW}" y2="${margin.top + plotH}" stroke="#334155" stroke-width="1.5"/>`;
            if (minP < 0) {
                const y0 = sy(0);
                html += `<line x1="${margin.left}" y1="${y0}" x2="${margin.left + plotW}" y2="${y0}" stroke="#94a3b8" stroke-width="1" stroke-dasharray="4"/>`;
            }

            // Axis labels
            html += `<text x="${margin.left + plotW / 2}" y="${H - 5}" text-anchor="middle" fill="#334155" font-size="12" font-weight="600">φMn (tf·m)</text>`;
            html += `<text x="15" y="${margin.top + plotH / 2}" text-anchor="middle" fill="#334155" font-size="12" font-weight="600" transform="rotate(-90,15,${margin.top + plotH / 2})">φPn (tf)</text>`;

            // φPn-φMn design curve
            let pathD = '';
            curve.forEach((pt, i) => {
                const x = sx(pt.phiMn_tfm), y = sy(pt.phiPn_tf);
                pathD += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1) + ' ';
            });
            html += `<path d="${pathD}" fill="none" stroke="#2563eb" stroke-width="2.5" stroke-linejoin="round"/>`;

            // Fill safe zone
            let fillD = pathD;
            fillD += `L${sx(0).toFixed(1)},${sy(curve[curve.length - 1].phiPn_tf).toFixed(1)} `;
            fillD += `L${sx(0).toFixed(1)},${sy(curve[0].phiPn_tf).toFixed(1)} Z`;
            html += `<path d="${fillD}" fill="#2563eb" opacity="0.08"/>`;

            // Pn-Mn nominal curve (dashed)
            let nomPathD = '';
            curve.forEach((pt, i) => {
                const x = sx(pt.Mn_tfm), y = sy(pt.Pn_tf);
                nomPathD += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1) + ' ';
            });
            html += `<path d="${nomPathD}" fill="none" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6,3" stroke-linejoin="round"/>`;

            // Special points
            const topPt = curve[curve.length - 1];
            html += `<circle cx="${sx(topPt.phiMn_tfm)}" cy="${sy(topPt.phiPn_tf)}" r="4" fill="#16a34a" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${sx(topPt.phiMn_tfm) + 6}" y="${sy(topPt.phiPn_tf) + 4}" fill="#16a34a" font-size="9" font-weight="600">φPo,max</text>`;

            const balPt = curve[balanceIdx];
            html += `<circle cx="${sx(balPt.phiMn_tfm)}" cy="${sy(balPt.phiPn_tf)}" r="4" fill="#f59e0b" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${sx(balPt.phiMn_tfm) + 6}" y="${sy(balPt.phiPn_tf) - 6}" fill="#f59e0b" font-size="9" font-weight="600">平衡點</text>`;

            const pbPt = curve[pureBendIdx];
            html += `<circle cx="${sx(pbPt.phiMn_tfm)}" cy="${sy(pbPt.phiPn_tf)}" r="4" fill="#8b5cf6" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${sx(pbPt.phiMn_tfm) + 6}" y="${sy(pbPt.phiPn_tf) + 12}" fill="#8b5cf6" font-size="9" font-weight="600">純彎</text>`;

            // Load points
            loadPoints.forEach(lp => {
                const dpx = sx(lp.Mu_tfm), dpy = sy(lp.Pu_tf);
                const color = lp.safe ? '#16a34a' : '#ef4444';
                html += `<circle cx="${dpx}" cy="${dpy}" r="6" fill="${color}" stroke="white" stroke-width="2"/>`;
                html += `<text x="${dpx + 8}" y="${dpy - 4}" fill="${color}" font-size="9" font-weight="700">#${lp.idx}</text>`;
            });

            // Legend
            const lgX = margin.left + plotW - 130, lgY = margin.top + 10;
            html += `<rect x="${lgX}" y="${lgY}" width="135" height="75" rx="4" fill="white" stroke="#e2e8f0" stroke-width="1"/>`;
            html += `<line x1="${lgX + 8}" y1="${lgY + 15}" x2="${lgX + 30}" y2="${lgY + 15}" stroke="#2563eb" stroke-width="2.5"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 19}" fill="#334155" font-size="10">φPn-φMn（設計）</text>`;
            html += `<line x1="${lgX + 8}" y1="${lgY + 32}" x2="${lgX + 30}" y2="${lgY + 32}" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6,3"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 36}" fill="#334155" font-size="10">Pn-Mn（標稱）</text>`;
            html += `<circle cx="${lgX + 19}" cy="${lgY + 49}" r="4" fill="#16a34a" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 53}" fill="#334155" font-size="10">安全</text>`;
            html += `<circle cx="${lgX + 19}" cy="${lgY + 66}" r="4" fill="#ef4444" stroke="white" stroke-width="1.5"/>`;
            html += `<text x="${lgX + 35}" y="${lgY + 70}" fill="#334155" font-size="10">不安全</text>`;

            // Title
            html += `<text x="${W / 2}" y="18" text-anchor="middle" fill="#334155" font-size="13" font-weight="700">2D P-M 交互作用曲線 (α=${alphaDeg.toFixed(1)}°)</text>`;

            svg.innerHTML = html;

            // Status
            const safeCount = loadPoints.filter(lp => lp.safe).length;
            const totalCount = loadPoints.length;
            if (safeCount === totalCount) {
                statusDiv.innerHTML = `<span style="color:#16a34a;">✓ 全部安全：${totalCount} 筆載重組合皆位於 P-M 曲線內</span>`;
            } else {
                statusDiv.innerHTML = `<span style="color:#ef4444;">✗ ${totalCount - safeCount}/${totalCount} 筆載重不安全：設計點位於 P-M 曲線外</span>`;
            }

            // Draw section preview with α vector
            drawAlphaSectionPreview(alphaDeg);
        }

        function drawAlphaSectionPreview(alphaDeg) {
            const svg = document.getElementById('pm-2d-section-svg');
            const outer = rcColData.outer;
            const hollow = rcColData.hollow;
            const rebars = rcColData.rebars;

            if (outer.length < 3) {
                svg.innerHTML = '<text x="150" y="150" text-anchor="middle" fill="#94a3b8" font-size="12">無斷面資料</text>';
                return;
            }

            // Bounding box
            let allPts = [...outer];
            if (hollow.length > 0) allPts = allPts.concat(hollow);
            rebars.forEach(r => allPts.push({ x: r.x, y: r.y }));

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            allPts.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
            });

            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const svgW = 300, svgH = 300;
            const mgn = 30;
            const drawW = svgW - 2 * mgn;
            const drawH = svgH - 2 * mgn;
            const scale = Math.min(drawW / rangeX, drawH / rangeY);
            const offX = mgn + (drawW - rangeX * scale) / 2;
            const offY = mgn + (drawH - rangeY * scale) / 2;

            function tx(x) { return offX + (x - minX) * scale; }
            function ty(y) { return offY + (maxY - y) * scale; }

            let h = '';
            h += `<rect x="0" y="0" width="${svgW}" height="${svgH}" fill="#fafbfc"/>`;

            // Outer polygon
            const outerPts = outer.map(p => tx(p.x) + ',' + ty(p.y)).join(' ');
            h += `<polygon points="${outerPts}" fill="#e0e7ff" stroke="#2563eb" stroke-width="2"/>`;

            // Hollow polygon
            if (hollow.length >= 3) {
                const hollowPts = hollow.map(p => tx(p.x) + ',' + ty(p.y)).join(' ');
                h += `<polygon points="${hollowPts}" fill="#fafbfc" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="4"/>`;
            }

            // Rebars
            rebars.forEach(rb => {
                const sx = tx(rb.x), sy = ty(rb.y);
                const info = rebarInfo[rb.no] || rebarInfo[8];
                const r = Math.max(2, Math.min(6, info.dia * scale / 2));
                h += `<circle cx="${sx}" cy="${sy}" r="${r}" fill="#ef4444" stroke="#b91c1c" stroke-width="0.8"/>`;
            });

            // Plastic centroid + α vector
            if (rcColData.pcX !== null && rcColData.pcY !== null) {
                const pcSx = tx(rcColData.pcX), pcSy = ty(rcColData.pcY);
                // PC cross mark
                h += `<line x1="${pcSx - 5}" y1="${pcSy}" x2="${pcSx + 5}" y2="${pcSy}" stroke="#16a34a" stroke-width="2"/>`;
                h += `<line x1="${pcSx}" y1="${pcSy - 5}" x2="${pcSx}" y2="${pcSy + 5}" stroke="#16a34a" stroke-width="2"/>`;
                h += `<circle cx="${pcSx}" cy="${pcSy}" r="3.5" fill="none" stroke="#16a34a" stroke-width="1.5"/>`;
                h += `<text x="${pcSx + 7}" y="${pcSy - 7}" fill="#16a34a" font-size="9" font-weight="bold">PC</text>`;

                // α direction arrow
                const alphaRad = alphaDeg * Math.PI / 180;
                const arrowLen = Math.min(drawW, drawH) * 0.4;
                const ax = pcSx + arrowLen * Math.cos(alphaRad);
                const ay = pcSy - arrowLen * Math.sin(alphaRad);
                h = `<defs><marker id="arrowAlpha2d" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6 Z" fill="#f59e0b"/></marker></defs>` + h;
                h += `<line x1="${pcSx}" y1="${pcSy}" x2="${ax}" y2="${ay}" stroke="#f59e0b" stroke-width="2.5" marker-end="url(#arrowAlpha2d)"/>`;
                const labelX = pcSx + (arrowLen + 10) * Math.cos(alphaRad);
                const labelY = pcSy - (arrowLen + 10) * Math.sin(alphaRad);
                h += `<text x="${labelX}" y="${labelY}" fill="#f59e0b" font-size="10" font-weight="bold" text-anchor="middle">α=${alphaDeg.toFixed(1)}°</text>`;
            }

            // Axes info
            h += `<text x="8" y="${svgH - 6}" fill="#94a3b8" font-size="9">Y↑ X→</text>`;

            svg.innerHTML = h;
        }

        function isPointInsidePMCurve(curve, Pu_tf, Mu_tfm) {
            // Check if Pu is within the axial capacity range
            const maxP = Math.max(...curve.map(c => c.phiPn_tf));
            const minP = Math.min(...curve.map(c => c.phiPn_tf));
            if (Pu_tf > maxP || Pu_tf < minP) return false;

            // Collect maximum M capacity across ALL bracket intervals at Pu level
            // (P-M curve is non-monotonic: P rises then falls, so multiple brackets may exist)
            let maxMCapacity = -Infinity;
            let foundBracket = false;
            for (let i = 0; i < curve.length - 1; i++) {
                const p1 = curve[i].phiPn_tf, p2 = curve[i + 1].phiPn_tf;
                const m1 = curve[i].phiMn_tfm, m2 = curve[i + 1].phiMn_tfm;
                if ((p1 <= Pu_tf && p2 >= Pu_tf) || (p1 >= Pu_tf && p2 <= Pu_tf)) {
                    if (Math.abs(p2 - p1) < 1e-10) continue;
                    const t = (Pu_tf - p1) / (p2 - p1);
                    const mCapacity = m1 + t * (m2 - m1);
                    if (mCapacity > maxMCapacity) maxMCapacity = mCapacity;
                    foundBracket = true;
                }
            }
            if (foundBracket) return Mu_tfm <= maxMCapacity;

            // Fallback: use max M at closest P
            let closestIdx = 0, closestDist = Infinity;
            curve.forEach((pt, i) => {
                const d = Math.abs(pt.phiPn_tf - Pu_tf);
                if (d < closestDist) { closestDist = d; closestIdx = i; }
            });
            return Mu_tfm <= curve[closestIdx].phiMn_tfm;
        }

        function interpolateSurfaceAtAngle(surface, angleDeg) {
            // Normalize angle to [0, 360)
            let a = ((angleDeg % 360) + 360) % 360;

            // Find the two adjacent slices that bracket this angle
            // Surface slices are at 0, 15, 30, ..., 345, 360 degrees
            let loSlice = null, hiSlice = null;
            for (let i = 0; i < surface.length - 1; i++) {
                if (surface[i].angle <= a && surface[i + 1].angle >= a) {
                    loSlice = surface[i];
                    hiSlice = surface[i + 1];
                    break;
                }
            }
            if (!loSlice) {
                // Exact match at 360 or fallback to closest
                return surface[0].curve;
            }

            // If exact match, no interpolation needed
            const span = hiSlice.angle - loSlice.angle;
            if (span < 1e-10) return loSlice.curve;
            const t = (a - loSlice.angle) / span;

            // Interpolate point-by-point (both curves have the same number of points)
            const len = Math.min(loSlice.curve.length, hiSlice.curve.length);
            const result = [];
            for (let i = 0; i < len; i++) {
                const lo = loSlice.curve[i];
                const hi = hiSlice.curve[i];
                result.push({
                    phiPn_tf: lo.phiPn_tf + t * (hi.phiPn_tf - lo.phiPn_tf),
                    phiMn_tfm: lo.phiMn_tfm + t * (hi.phiMn_tfm - lo.phiMn_tfm),
                    phiMnx_tfm: lo.phiMnx_tfm + t * (hi.phiMnx_tfm - lo.phiMnx_tfm),
                    phiMny_tfm: lo.phiMny_tfm + t * (hi.phiMny_tfm - lo.phiMny_tfm),
                    Pn_tf: lo.Pn_tf + t * (hi.Pn_tf - lo.Pn_tf),
                    Mn_tfm: lo.Mn_tfm + t * (hi.Mn_tfm - lo.Mn_tfm),
                    phi: lo.phi + t * (hi.phi - lo.phi),
                    epsT: lo.epsT + t * (hi.epsT - lo.epsT),
                    c: lo.c + t * (hi.c - lo.c)
                });
            }
            return result;
        }

        function addLoadCase(Pu, Mux, Muy) {
            const tbody = document.querySelector('#rcc-loads-table tbody');
            const tr = document.createElement('tr');
            tr.innerHTML = `
        <td class="rcc-load-idx"></td>
        <td><input type="number" value="${Pu ?? 0}" step="1"></td>
        <td><input type="number" value="${Mux ?? 0}" step="0.5" oninput="updateLoadAlphas()"></td>
        <td><input type="number" value="${Muy ?? 0}" step="0.5" oninput="updateLoadAlphas()"></td>
        <td class="rcc-load-alpha">—</td>
        <td><button class="rcc-load-del" onclick="removeLoadCase(this)">✕</button></td>`;
            tbody.appendChild(tr);
            renumberLoadCases();
        }

        function removeLoadCase(btn) {
            const tbody = document.querySelector('#rcc-loads-table tbody');
            if (tbody.rows.length <= 1) return;
            btn.closest('tr').remove();
            renumberLoadCases();
        }

        function renumberLoadCases() {
            const rows = document.querySelectorAll('#rcc-loads-table tbody tr');
            rows.forEach((tr, i) => { tr.querySelector('.rcc-load-idx').textContent = i + 1; });
        }

        function getLoadCases() {
            const rows = document.querySelectorAll('#rcc-loads-table tbody tr');
            const cases = [];
            rows.forEach(tr => {
                const inputs = tr.querySelectorAll('input');
                cases.push({
                    Pu: parseFloat(inputs[0].value) || 0,
                    Mux: parseFloat(inputs[1].value) || 0,
                    Muy: parseFloat(inputs[2].value) || 0
                });
            });
            return cases;
        }

        function updateLoadAlphas() {
            const rows = document.querySelectorAll('#rcc-loads-table tbody tr');
            rows.forEach(tr => {
                const inputs = tr.querySelectorAll('input');
                const Mux = parseFloat(inputs[1].value) || 0;
                const Muy = parseFloat(inputs[2].value) || 0;
                const alphaCell = tr.querySelector('.rcc-load-alpha');
                if (Math.abs(Mux) < 1e-12 && Math.abs(Muy) < 1e-12) {
                    alphaCell.textContent = '—';
                } else {
                    const alpha = Math.atan2(-Mux, Muy) * 180 / Math.PI;
                    alphaCell.textContent = alpha.toFixed(1);
                }
            });
        }

        // 記憶最後存取路徑（IndexedDB 跨工作階段保存）
        let lastCsvDirHandle = null;

        function openHandleDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('RCColumnCSV', 1);
                req.onupgradeneeded = () => req.result.createObjectStore('handles');
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function saveLastHandle(handle) {
            try {
                lastCsvDirHandle = handle;
                const db = await openHandleDB();
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'lastCsvHandle');
                await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
                db.close();
            } catch (e) { /* ignore */ }
        }

        async function loadLastHandle() {
            try {
                const db = await openHandleDB();
                const tx = db.transaction('handles', 'readonly');
                const handle = await new Promise((res, rej) => {
                    const req = tx.objectStore('handles').get('lastCsvHandle');
                    req.onsuccess = () => res(req.result);
                    req.onerror = () => rej(req.error);
                });
                db.close();
                if (handle) lastCsvDirHandle = handle;
            } catch (e) { /* ignore */ }
        }

        // 頁面載入時讀取上次路徑
        loadLastHandle();

        function _buildCSVString() {
            let csv = '';

            // [OUTER]
            csv += '[OUTER]\n';
            csv += 'x,y\n';
            rcColData.outer.forEach(p => { csv += `${p.x},${p.y}\n`; });

            // [HOLLOW]
            csv += '\n[HOLLOW]\n';
            csv += 'x,y\n';
            rcColData.hollow.forEach(p => { csv += `${p.x},${p.y}\n`; });

            // [MATERIAL]
            csv += '\n[MATERIAL]\n';
            csv += 'fc,fy,Es\n';
            const fc = document.getElementById('rcc-fc').value;
            const fy = document.getElementById('rcc-fy').value;
            const Es = document.getElementById('rcc-Es').value;
            csv += `${fc},${fy},${Es}\n`;

            // [REBAR_CONFIG]
            csv += '\n[REBAR_CONFIG]\n';
            csv += 'minSpacing\n';
            csv += `${document.getElementById('rcc-spacing').value}\n`;

            // [REBARS]
            csv += '\n[REBARS]\n';
            csv += 'x,y,no,area\n';
            rcColData.rebars.forEach(rb => {
                const area = rb.area || (rebarInfo[rb.no] || rebarInfo[8]).area;
                csv += `${rb.x},${rb.y},${rb.no},${area}\n`;
            });

            // [LOADS]
            csv += '\n[LOADS]\n';
            csv += 'Pu,Mux,Muy\n';
            getLoadCases().forEach(lc => { csv += `${lc.Pu},${lc.Mux},${lc.Muy}\n`; });

            // [PM_CURVE_xxx] from 3D surface
            if (window.lastPMSurface) {
                window.lastPMSurface.forEach(slice => {
                    csv += `\n[PM_CURVE_${slice.angle}]\n`;
                    csv += 'phiPn_tf,phiMn_tfm,Pn_tf,Mn_tfm,phi,epsT,c\n';
                    const curve = slice.curve;
                    let hasZero = false;
                    for (let i = 0; i < curve.length; i++) {
                        const pt = curve[i];
                        // 在跨越 phiPn=0 的相鄰點之間插入內插點
                        if (i > 0 && !hasZero) {
                            const prev = curve[i - 1];
                            if ((prev.phiPn_tf > 0 && pt.phiPn_tf < 0) || (prev.phiPn_tf < 0 && pt.phiPn_tf > 0)) {
                                const dP = pt.phiPn_tf - prev.phiPn_tf;
                                if (Math.abs(dP) > 1e-12) {
                                    const t = -prev.phiPn_tf / dP;
                                    const lerp = (a, b) => a + t * (b - a);
                                    const f = v => v.toFixed(4);
                                    csv += `0,${f(lerp(prev.phiMn_tfm, pt.phiMn_tfm))},${f(lerp(prev.Pn_tf, pt.Pn_tf))},${f(lerp(prev.Mn_tfm, pt.Mn_tfm))},${lerp(prev.phi, pt.phi)},${lerp(prev.epsT, pt.epsT)},${lerp(prev.c, pt.c)}\n`;
                                    hasZero = true;
                                }
                            }
                        }
                        if (Math.abs(pt.phiPn_tf) < 1e-10) hasZero = true;
                        csv += `${pt.phiPn_tf.toFixed(4)},${pt.phiMn_tfm.toFixed(4)},${pt.Pn_tf.toFixed(4)},${pt.Mn_tfm.toFixed(4)},${pt.phi},${pt.epsT},${pt.c}\n`;
                    }
                });
            }

            // [BALANCE] balanced point data per angle
            if (window.lastPMSurface) {
                csv += '\n[BALANCE]\n';
                csv += 'angle,cb,Pn_b_tf,Mn_b_tfm,phiPn_b_tf,phiMn_b_tfm,phi,epsT\n';
                window.lastPMSurface.forEach(slice => {
                    if (slice.balanceIdx != null && slice.balanceIdx >= 0 && slice.balanceIdx < slice.curve.length) {
                        const bp = slice.curve[slice.balanceIdx];
                        const f = v => v.toFixed(4);
                        csv += `${slice.angle},${f(slice.cb)},${f(bp.Pn_tf)},${f(bp.Mn_tfm)},${f(bp.phiPn_tf)},${f(bp.phiMn_tfm)},${bp.phi},${bp.epsT}\n`;
                    }
                });
            }

            return csv;
        }

        async function exportRCColumnCSV() {
            const csv = _buildCSVString();
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });

            if (window.showSaveFilePicker) {
                try {
                    const opts = {
                        id: 'rcc-csv',
                        suggestedName: 'rc_column_data.csv',
                        types: [{ description: 'CSV 檔案', accept: { 'text/csv': ['.csv'] } }]
                    };
                    if (lastCsvDirHandle) opts.startIn = lastCsvDirHandle;
                    const handle = await window.showSaveFilePicker(opts);
                    await saveLastHandle(handle);
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    // Verify write succeeded by reading back file size
                    const written = await handle.getFile();
                    if (written.size !== blob.size) {
                        alert('CSV 匯出警告：檔案可能未正確寫入（檔案被其他程式鎖定？），請關閉佔用程式後重試。');
                    }
                } catch (err) {
                    if (err.name === 'AbortError') return;
                    alert('CSV 匯出失敗：檔案可能被其他程式（如 Excel）鎖定，請關閉後重試。\n(' + err.message + ')');
                    console.error(err);
                }
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rc_column_data.csv';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // ── WPF 橋接輔助函式 ─────────────────────────────────────────
        // 供 WPF C# 橋接呼叫：取得 CSV 字串
        window._buildCSVContent = function() {
            return _buildCSVString();
        };

        // 供 WPF C# 橋接呼叫：處理匯入的 CSV 文字
        window._processImportedCSV = function(text) {
            _parseAndApplyCSV(text);
        };

        // ── HTTP API 計算函式（供 VBA / 外部程式呼叫）───────────────────
        // 輸入：JSON 字串，含 fc, fy, Es, outer, hollow, rebars, loads
        // 輸出：JSON 字串，含 section, balancePoints, loadResults
        window._apiCalc = function(inputJson) {
            try {
                const inp = JSON.parse(inputJson);
                const fc  = inp.fc  || 280;
                const fy  = inp.fy  || 4200;
                const Es  = inp.Es  || 2040000;
                const outer  = (inp.outer  || []).map(p => ({ x: p[0], y: p[1] }));
                const hollow = (inp.hollow || []).map(p => ({ x: p[0], y: p[1] }));
                const rebars = (inp.rebars || []).map(r => ({ x: r.x, y: r.y, area: r.area, no: r.no || 0 }));
                const loads  = inp.loads || [];

                if (outer.length < 3) return JSON.stringify({ ok: false, error: '外輪廓頂點不足（至少3點）' });

                // 計算塑性中心
                const outerP  = polyProps(outer);
                const hollowP = hollow.length >= 3 ? polyProps(hollow) : { area: 0, cx: outerP.cx, cy: outerP.cy };
                const Anet = outerP.area - hollowP.area;
                let totalAs = 0;
                rebars.forEach(rb => totalAs += rb.area);
                const Ac = Anet - totalAs;
                const netCx = Anet > 0 ? (outerP.area * outerP.cx - hollowP.area * hollowP.cx) / Anet : outerP.cx;
                const netCy = Anet > 0 ? (outerP.area * outerP.cy - hollowP.area * hollowP.cy) / Anet : outerP.cy;
                let rebarXSum = 0, rebarYSum = 0;
                rebars.forEach(rb => { rebarXSum += rb.x * rb.area; rebarYSum += rb.y * rb.area; });
                const Fc_pc  = 0.85 * fc * Ac;
                const Fs_pc  = fy * totalAs;
                const pcTot  = Fc_pc + Fs_pc;
                const pcX = pcTot > 0 ? (Fc_pc * netCx + fy * rebarXSum) / pcTot : outerP.cx;
                const pcY = pcTot > 0 ? (Fc_pc * netCy + fy * rebarYSum) / pcTot : outerP.cy;

                // 產生 3D 曲面（所有角度）
                const surface = generate3DSurface(outer, hollow, rebars, fc, fy, Es, pcX, pcY);

                // 各角度平衡點
                const balancePoints = surface.map(s => {
                    const bp = s.curve[s.balanceIdx];
                    return {
                        angle:    s.angle,
                        cb:       parseFloat(s.cb.toFixed(4)),
                        Pn_b:     parseFloat(bp.Pn_tf.toFixed(3)),
                        Mn_b:     parseFloat(bp.Mn_tfm.toFixed(3)),
                        phiPn_b:  parseFloat(bp.phiPn_tf.toFixed(3)),
                        phiMn_b:  parseFloat(bp.phiMn_tfm.toFixed(3)),
                        phi:      bp.phi,
                        epsT:     parseFloat(bp.epsT.toFixed(6))
                    };
                });

                // 載重組合安全檢核
                const beta1 = fc <= 280 ? 0.85 : (fc >= 560 ? 0.65 : 0.85 - 0.05 * (fc - 280) / 70);
                const Po = 0.85 * fc * Ac + fy * totalAs;
                const loadResults = loads.map((lc, i) => {
                    const alpha = Math.atan2(-lc.Mux, lc.Muy) * 180 / Math.PI;
                    const Mu    = Math.sqrt(lc.Mux * lc.Mux + lc.Muy * lc.Muy);
                    const interpCurve = interpolateSurfaceAtAngle(surface, alpha);
                    const safe  = isPointInsidePMCurve(interpCurve, lc.Pu, Mu);
                    return {
                        idx:      i + 1,
                        Pu_tf:    lc.Pu,
                        Mux_tfm:  lc.Mux,
                        Muy_tfm:  lc.Muy,
                        Mu_tfm:   parseFloat(Mu.toFixed(3)),
                        alpha_deg: parseFloat(alpha.toFixed(2)),
                        safe:     safe
                    };
                });

                return JSON.stringify({
                    ok: true,
                    section: {
                        Ag:          parseFloat(outerP.area.toFixed(2)),
                        Ah:          parseFloat(hollowP.area.toFixed(2)),
                        Anet:        parseFloat(Anet.toFixed(2)),
                        Ast:         parseFloat(totalAs.toFixed(2)),
                        Ac:          parseFloat(Ac.toFixed(2)),
                        rhoG_pct:    parseFloat((totalAs / Anet * 100).toFixed(3)),
                        pcX:         parseFloat(pcX.toFixed(3)),
                        pcY:         parseFloat(pcY.toFixed(3)),
                        beta1:       beta1,
                        Po_tf:       parseFloat((Po / 1000).toFixed(2)),
                        phiPo_max_tf:parseFloat((0.80 * 0.65 * Po / 1000).toFixed(2))
                    },
                    balancePoints,
                    loadResults
                });
            } catch (e) {
                return JSON.stringify({ ok: false, error: e.message });
            }
        };
        // ─────────────────────────────────────────────────────────────

        async function importRCColumnCSV() {
            let file;
            if (window.showOpenFilePicker) {
                try {
                    const opts = {
                        id: 'rcc-csv',
                        types: [{ description: 'CSV 檔案', accept: { 'text/csv': ['.csv'] } }]
                    };
                    if (lastCsvDirHandle) opts.startIn = lastCsvDirHandle;
                    const [handle] = await window.showOpenFilePicker(opts);
                    await saveLastHandle(handle);
                    file = await handle.getFile();
                } catch (err) {
                    if (err.name !== 'AbortError') console.error(err);
                    return;
                }
            } else {
                // Fallback for browsers without File System Access API
                file = await new Promise(resolve => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    input.onchange = () => resolve(input.files[0]);
                    input.click();
                });
                if (!file) return;
            }

            const text = await file.text();
            _parseAndApplyCSV(text);
        }

        function _parseAndApplyCSV(text) {
            const lines = text.split(/\r?\n/);

            // Parse sections
            const sections = {};
            let currentSection = null;
            lines.forEach(line => {
                const trimmed = line.trim();
                if (!trimmed) return;
                const sectionMatch = trimmed.match(/^\[(.+)\]$/);
                if (sectionMatch) {
                    currentSection = sectionMatch[1];
                    sections[currentSection] = [];
                } else if (currentSection) {
                    sections[currentSection].push(trimmed);
                }
            });

            // Helper: parse CSV rows (skip header)
            function parseRows(sectionName) {
                const rows = sections[sectionName];
                if (!rows || rows.length < 2) return [];
                return rows.slice(1).map(r => r.split(',').map(v => v.trim()));
            }

            // [OUTER]
            const outerRows = parseRows('OUTER');
            if (outerRows.length >= 3) {
                rcColData.outer = outerRows.map(r => ({ x: parseFloat(r[0]) || 0, y: parseFloat(r[1]) || 0 }));
            }

            // [HOLLOW]
            const hollowRows = parseRows('HOLLOW');
            rcColData.hollow = hollowRows.map(r => ({ x: parseFloat(r[0]) || 0, y: parseFloat(r[1]) || 0 }));

            // [MATERIAL]
            const matRows = parseRows('MATERIAL');
            if (matRows.length >= 1) {
                document.getElementById('rcc-fc').value = matRows[0][0] || 280;
                document.getElementById('rcc-fy').value = matRows[0][1] || 4200;
                document.getElementById('rcc-Es').value = matRows[0][2] || 2040000;
            }

            // [REBAR_CONFIG]
            const cfgRows = parseRows('REBAR_CONFIG');
            if (cfgRows.length >= 1) {
                document.getElementById('rcc-spacing').value = cfgRows[0][0] || 10;
            }

            // [REBARS]
            const rebarRows = parseRows('REBARS');
            rcColData.rebars = rebarRows.map(r => ({
                x: parseFloat(r[0]) || 0,
                y: parseFloat(r[1]) || 0,
                no: parseInt(r[2]) || 0,
                area: parseFloat(r[3]) || 0
            }));

            // [LOADS]
            const loadRows = parseRows('LOADS');
            const tbody = document.querySelector('#rcc-loads-table tbody');
            tbody.innerHTML = '';
            if (loadRows.length > 0) {
                loadRows.forEach(r => {
                    addLoadCase(parseFloat(r[0]) || 0, parseFloat(r[1]) || 0, parseFloat(r[2]) || 0);
                });
            } else {
                addLoadCase(0, 0, 0);
            }

            // Set preset to custom since we're loading arbitrary geometry
            document.getElementById('rcc-preset').value = '';
            document.getElementById('rcc-shape-params').style.display = 'none';

            // Update UI
            renderOuterTable();
            renderHollowTable();
            renderRebarTable();
            updateCover();
            drawRCColPreview();
            updateLoadAlphas();

            alert('匯入完成！請按「計算交互作用曲線」重新計算 P-M 曲線。');
        }

        function calcRCColumn() {
            const outer = rcColData.outer;
            if (outer.length < 3) {
                alert('請輸入至少 3 個外輪廓頂點');
                return;
            }

            const fc = parseFloat(document.getElementById('rcc-fc').value) || 280;
            const fy = parseFloat(document.getElementById('rcc-fy').value) || 4200;

            // 取得多筆載重組合
            const loadCases = getLoadCases();

            // 外輪廓面積與重心
            const outerP = polyProps(outer);
            const areaGross = outerP.area;

            // 空心面積與重心
            const hollow = rcColData.hollow;
            const hollowP = polyProps(hollow);
            const areaHollow = hollowP.area;

            // 淨混凝土面積 (扣除空心與鋼筋)
            const rebars = rcColData.rebars;
            let totalAs = 0;
            rebars.forEach(rb => { totalAs += rb.area || (rebarInfo[rb.no] || rebarInfo[8]).area; });

            const areaNet = areaGross - areaHollow;
            const Ac = areaNet - totalAs; // 混凝土淨面積
            const rhoG = totalAs / areaNet * 100;

            // 塑性中心 (Plastic centroid)
            const concForce = 0.85 * fc * areaNet;
            let concMx = 0.85 * fc * areaGross * outerP.cx;
            let concMy = 0.85 * fc * areaGross * outerP.cy;
            if (areaHollow > 0) {
                concMx -= 0.85 * fc * areaHollow * hollowP.cx;
                concMy -= 0.85 * fc * areaHollow * hollowP.cy;
            }

            let steelForce = 0, steelMx = 0, steelMy = 0;
            rebars.forEach(rb => {
                const as = rb.area || (rebarInfo[rb.no] || rebarInfo[8]).area;
                const f = fy * as;
                steelForce += f;
                steelMx += f * rb.x;
                steelMy += f * rb.y;
            });

            const totalForce = concForce + steelForce;
            const pcX = totalForce !== 0 ? (concMx + steelMx) / totalForce : 0;
            const pcY = totalForce !== 0 ? (concMy + steelMy) / totalForce : 0;

            // 用第一筆載重計算 α 角（供 SVG 預覽箭頭使用）
            const alpha0 = Math.atan2(-loadCases[0].Mux, loadCases[0].Muy) * 180 / Math.PI;

            // 儲存供預覽繪圖使用
            rcColData.pcX = pcX;
            rcColData.pcY = pcY;
            rcColData.alpha = alpha0;
            drawRCColPreview();

            const Es = parseFloat(document.getElementById('rcc-Es').value) || 2040000;

            if (rebars.length === 0) {
                showResult('rccolumn', [
                    ['毛斷面積 Ag', fmt(areaGross, 2) + ' cm²'],
                    ['空心面積 Ah', fmt(areaHollow, 2) + ' cm²'],
                    ['淨斷面積 (Ag-Ah)', fmt(areaNet, 2) + ' cm²'],
                    ['混凝土淨面積 Ac = Ag−Ah−Ast', fmt(Ac, 2) + ' cm²'],
                    ['總鋼筋面積 Ast', '0 cm²'],
                    ['注意', '請先配置鋼筋再計算 P-M 曲線'],
                ]);
                document.getElementById('pm-chart-container').style.display = 'none';
                document.getElementById('pm-chart-2d-container').style.display = 'none';
                return;
            }

            const rebarsResolved = rebars.map(rb => ({
                x: rb.x, y: rb.y,
                area: rb.area || (rebarInfo[rb.no] || rebarInfo[8]).area
            }));

            // 先產生 3D 曲面（所有角度的 P-M 曲線），再逐筆載重內插檢核
            const pmSurface = generate3DSurface(outer, hollow, rebarsResolved, fc, fy, Es, pcX, pcY);

            // 用第一筆載重的角度取得 pmData 供顯示基本數據
            const alpha0Rad = alpha0 * Math.PI / 180;
            const pmData = generatePMCurve(outer, hollow, rebarsResolved, fc, fy, Es, pcX, pcY, alpha0Rad);

            // 逐筆載重計算：每筆使用自己的 α 角，從 3D 曲面內插對應 P-M 曲線
            const loadPoints = loadCases.map((lc, i) => {
                const lcAlpha = Math.atan2(-lc.Mux, lc.Muy) * 180 / Math.PI;
                const Mu_tfm = Math.sqrt(lc.Mux * lc.Mux + lc.Muy * lc.Muy);
                const Pu_tf = lc.Pu;
                // 從 3D 曲面內插該角度的 P-M 曲線
                const interpCurve = interpolateSurfaceAtAngle(pmSurface, lcAlpha);
                const safe = isPointInsidePMCurve(interpCurve, Pu_tf, Mu_tfm);
                return { idx: i + 1, Pu_tf, Mu_tfm, Mux: lc.Mux, Muy: lc.Muy, alpha: lcAlpha, safe };
            });

            // 結果表格
            const resultRows = [
                ['毛斷面積 Ag', fmt(areaGross, 2) + ' cm²'],
                ['空心面積 Ah', fmt(areaHollow, 2) + ' cm²'],
                ['淨斷面積 (Ag-Ah)', fmt(areaNet, 2) + ' cm²'],
                ['混凝土淨面積 Ac = Ag−Ah−Ast', fmt(Ac, 2) + ' cm²'],
                ['總鋼筋面積 Ast', fmt(totalAs, 2) + ' cm²'],
                ['鋼筋比 ρg', fmt(rhoG, 2) + ' %'],
                ['鋼筋根數', rebars.length + ' 根'],
                ['塑性中心 Xpc', fmt(pcX, 2) + ' cm'],
                ['塑性中心 Ypc', fmt(pcY, 2) + ' cm'],
                ['β₁', fmt(pmData.beta1, 4)],
                ['純壓強度 Po', fmt(pmData.Po_tf, 2) + ' tf'],
                ['φPo,max (0.80φPo)', fmt(pmData.phiPo_max_tf, 2) + ' tf'],
                ['平衡點 (α=' + fmt(alpha0, 1) + '°) cb', fmt(pmData.cb, 2) + ' cm'],
                ['平衡點 Pn_b', fmt(pmData.curve[pmData.balanceIdx].Pn_tf, 2) + ' tf'],
                ['平衡點 Mn_b', fmt(pmData.curve[pmData.balanceIdx].Mn_tfm, 2) + ' tf·m'],
                ['平衡點 φPn_b', fmt(pmData.curve[pmData.balanceIdx].phiPn_tf, 2) + ' tf'],
                ['平衡點 φMn_b', fmt(pmData.curve[pmData.balanceIdx].phiMn_tfm, 2) + ' tf·m'],
                ['平衡點 Cc', fmt(pmData.curve[pmData.balanceIdx].Cc_tf, 2) + ' tf'],
                ['平衡點 Cs', fmt(pmData.curve[pmData.balanceIdx].Cs_tf, 2) + ' tf'],
                ['平衡點 Ts', fmt(pmData.curve[pmData.balanceIdx].Ts_tf, 2) + ' tf'],
                ['純彎 φMo', fmt(pmData.curve[pmData.pureBendIdx].phiMn_tfm, 2) + ' tf·m'],
                ['───', '── 載重組合 ──'],
            ];
            loadPoints.forEach(lp => {
                const status = lp.safe ? '✓ 安全' : '✗ 不安全';
                const color = lp.safe ? '#16a34a' : '#ef4444';
                resultRows.push([
                    `#${lp.idx}: Pu=${fmt(lp.Pu_tf, 2)} tf, Mu=${fmt(lp.Mu_tfm, 2)} tf·m, α=${fmt(lp.alpha, 1)}°`,
                    `<span style="color:${color};font-weight:600">${status}</span>`
                ]);
            });

            showResult('rccolumn', resultRows);

            window.lastPMSurface = pmSurface;
            window.lastLoadPoints = loadPoints;

            const alpha2d = parseFloat(document.getElementById('pm-2d-alpha').value) || 0;
            drawPMChart2D(pmSurface, loadPoints, alpha2d);
            drawPMChart3D(pmSurface, loadPoints);
        }

        // 初始化預設矩形斷面
        function initRCColumn() {
            document.getElementById('rcc-preset').value = 'rect';
            onPresetChange('rect');
            updateCover();
            autoArrangeRebar();
            updateLoadAlphas();
        }

        // ===== 單位換算 =====
        const unitData = {
            length: {
                units: ['mm', 'cm', 'm', 'km', 'in', 'ft', 'yd'],
                toBase: { mm: 0.001, cm: 0.01, m: 1, km: 1000, in: 0.0254, ft: 0.3048, yd: 0.9144 }
            },
            area: {
                units: ['mm\u00B2', 'cm\u00B2', 'm\u00B2', '\u5761', '\u7532', 'ft\u00B2', 'in\u00B2'],
                toBase: { 'mm\u00B2': 1e-6, 'cm\u00B2': 1e-4, 'm\u00B2': 1, '\u5761': 3305.785, '\u7532': 2934, 'ft\u00B2': 0.0929, 'in\u00B2': 6.4516e-4 }
            },
            volume: {
                units: ['cm\u00B3', 'm\u00B3', 'L', 'gal(US)'],
                toBase: { 'cm\u00B3': 1e-6, 'm\u00B3': 1, 'L': 0.001, 'gal(US)': 0.003785 }
            },
            force: {
                units: ['N', 'kN', 'kgf', 'tf', 'lbf'],
                toBase: { N: 1, kN: 1000, kgf: 9.80665, tf: 9806.65, lbf: 4.44822 }
            },
            pressure: {
                units: ['Pa', 'kPa', 'MPa', 'kgf/cm\u00B2', 'psi', 'atm', 'bar'],
                toBase: { Pa: 1, kPa: 1e3, MPa: 1e6, 'kgf/cm\u00B2': 98066.5, psi: 6894.76, atm: 101325, bar: 1e5 }
            },
            moment: {
                units: ['N\u00B7m', 'kN\u00B7m', 'kgf\u00B7cm', 'kgf\u00B7m', 'tf\u00B7m', 'tf\u00B7cm', 'N\u00B7mm', 'lbf\u00B7ft'],
                toBase: { 'N\u00B7m': 1, 'kN\u00B7m': 1000, 'kgf\u00B7cm': 0.0980665, 'kgf\u00B7m': 9.80665, 'tf\u00B7m': 9806.65, 'tf\u00B7cm': 98.0665, 'N\u00B7mm': 0.001, 'lbf\u00B7ft': 1.35582 }
            }
        };

        function updateUnitOptions() {
            const cat = sel('unit-cat');
            const units = unitData[cat].units;
            const fromSel = document.getElementById('unit-from');
            const toSel = document.getElementById('unit-to');
            fromSel.innerHTML = units.map((u, i) => `<option value="${u}" ${i === 0 ? 'selected' : ''}>${u}</option>`).join('');
            toSel.innerHTML = units.map((u, i) => `<option value="${u}" ${i === 1 ? 'selected' : ''}>${u}</option>`).join('');
        }

        function calcUnit() {
            const cat = sel('unit-cat');
            const v = val('unit-val');
            const from = sel('unit-from'), to = sel('unit-to');
            const base = unitData[cat].toBase;
            const result = v * base[from] / base[to];
            showResult('unit', [
                ['\u8F38\u5165', v + ' ' + from],
                ['\u7D50\u679C', fmt(result, 6) + ' ' + to],
            ]);
        }

        // Init
        updateUnitOptions();
        initUnitSelectors();
        initRCColumn();
        // ===== 3D Generation & Plotting =====
        function generate3DSurface(outer, hollow, rebars, fc, fy, Es, pcX, pcY) {
            const surface = [];
            // Step 15 degrees: 24 steps -> 0 to 360
            for (let deg = 0; deg <= 360; deg += 15) {
                const rad = deg * Math.PI / 180;
                const data = generatePMCurve(outer, hollow, rebars, fc, fy, Es, pcX, pcY, rad);
                surface.push({ angle: deg, curve: data.curve, balanceIdx: data.balanceIdx, cb: data.cb });
            }
            return surface;
        }

        function drawPMChart3D(surface, loadPoints) {
            // Settings
            const surfColor = document.getElementById('pm-color-surf') ? document.getElementById('pm-color-surf').value : '#3b82f6';
            const wireColor = document.getElementById('pm-color-wire') ? document.getElementById('pm-color-wire').value : '#ffffff';
            const safeColor = document.getElementById('pm-color-safe') ? document.getElementById('pm-color-safe').value : '#16a34a';
            const unsafeColor = document.getElementById('pm-color-unsafe') ? document.getElementById('pm-color-unsafe').value : '#ef4444';
            const opacity = document.getElementById('pm-opacity') ? parseFloat(document.getElementById('pm-opacity').value) : 0.5;
            const scaleZ = document.getElementById('pm-scale-z') ? parseFloat(document.getElementById('pm-scale-z').value) : 1.5;
            const scaleXY = document.getElementById('pm-scale-xy') ? parseFloat(document.getElementById('pm-scale-xy').value) : 1.0;
            const strengthType = document.getElementById('pm-strength-type') ? document.getElementById('pm-strength-type').value : 'design';

            // Select data fields based on strength type
            const keyPn = strengthType === 'nominal' ? 'Pn_tf' : 'phiPn_tf';
            const keyMnx = strengthType === 'nominal' ? 'Mnx_tfm' : 'phiMnx_tfm';
            const keyMny = strengthType === 'nominal' ? 'Mny_tfm' : 'phiMny_tfm';
            const axisLabelP = strengthType === 'nominal' ? 'Pn (tf)' : 'φPn (tf)';
            const axisLabelMx = strengthType === 'nominal' ? 'Mnx (tf·m)' : 'φMnx (tf·m)';
            const axisLabelMy = strengthType === 'nominal' ? 'Mny (tf·m)' : 'φMny (tf·m)';

            if (typeof Plotly === 'undefined') {
                document.getElementById('pm-status').innerHTML += '<br><span style="color:orange">正在載入 3D 圖表套件... (需網路連線)</span>';
                // Retry after 1s
                setTimeout(() => drawPMChart3D(surface, loadPoints), 1000);
                return;
            }

            const traces = [];

            // 1. Surface Mesh (Semi-transparent surface)
            // Flatten data for mesh3d
            const meshX = [], meshY = [], meshZ = [];
            surface.forEach(slice => {
                slice.curve.forEach(p => {
                    meshX.push(p[keyMnx]);
                    meshY.push(p[keyMny]);
                    meshZ.push(p[keyPn]);
                });
            });

            traces.push({
                type: 'mesh3d',
                x: meshX, y: meshY, z: meshZ,
                alphahull: 0, // Convex hull approx? No, alphahull 0 is convex hull. 
                // Our surface is convex-ish but tube-like.
                // Better to use 'surface' trace type?
                // 'surface' requires 2D grid (z[y][x]).
                // We have grid data: surface[angle_idx].curve[c_idx].
                // Let's construct 2D array for 'surface' trace.
                opacity: 0.5,
                color: '#3b82f6'
            });

            // Re-implement using 'surface' trace for better topology
            // surface[i] is angle i. curve[j] is point j.
            // Plotly surface expects z as 2D array. x and y as 2D arrays.
            const surfX = [], surfY = [], surfZ = [];
            const numAngle = surface.length;
            const numCurve = surface[0].curve.length;

            // Loop c (rows), then angle (cols) ? Or vice versa.
            // Plotly: z[m][n], x[m][n], y[m][n].
            // Let rows be 'c' level (iso-P approx), cols be 'angle'.
            for (let j = 0; j < numCurve; j++) { // increasing c (decreasing P)
                const rowX = [], rowY = [], rowZ = [];
                for (let i = 0; i < numAngle; i++) {
                    const p = surface[i].curve[j];
                    rowX.push(p[keyMnx]);
                    rowY.push(p[keyMny]);
                    rowZ.push(p[keyPn]);
                }
                surfX.push(rowX);
                surfY.push(rowY);
                surfZ.push(rowZ);
            }

            // Clear previous mesh attempt, use 'surface' trace
            traces.pop();
            traces.push({
                type: 'surface',
                x: surfX,
                y: surfY,
                z: surfZ,
                showscale: false, // Hide color bar
                opacity: opacity,
                colorscale: [[0, surfColor], [1, surfColor]],
                contours: {
                    x: { show: true, color: wireColor + '4D' },
                    y: { show: true, color: wireColor + '4D' },
                    z: { show: true, color: wireColor + '4D' }
                },
                lighting: {
                    ambient: 0.6,
                    diffuse: 0.5,
                    roughness: 0.5,
                    fresnel: 0.5
                },
                hoverinfo: 'x+y+z'
            });

            // 2. Wireframe (Optional, surface contours might be enough, but wireframe adds definition)
            // Existing wireframe code is fine, but maybe reduce opacity if surface is on.
            // Let's keep longitudinal lines for "Angle" reference.
            surface.forEach(slice => {
                const x = slice.curve.map(p => p[keyMnx]);
                const y = slice.curve.map(p => p[keyMny]);
                const z = slice.curve.map(p => p[keyPn]);

                traces.push({
                    type: 'scatter3d',
                    mode: 'lines',
                    x: x, y: y, z: z,
                    line: { color: 'rgba(255, 255, 255, 0.3)', width: 2 }, // White lines on blue surface
                    showlegend: false,
                    hoverinfo: 'none'
                });
            });

            // 3. Latitudinal lines (Optional, surface has them via contours)
            // Remove manual latitudinal loops to save performance if surface contours are on.
            // But let's keep them if user wants "grid".
            // If I use 'surface' trace with 'contours', I don't need manual lines.
            // I will COMMENT OUT manual latitudinal lines.


            // 3. Load Points
            traces.push({
                type: 'scatter3d',
                mode: 'markers+text',
                x: loadPoints.map(p => p.Mux),
                y: loadPoints.map(p => p.Muy),
                z: loadPoints.map(p => p.Pu_tf),
                marker: { size: 5, color: loadPoints.map(p => p.safe ? safeColor : unsafeColor) },
                text: loadPoints.map(p => `#${p.idx}`),
                name: '載重點'
            });

            const layout = {
                title: '3D P-M Interaction Surface',
                scene: {
                    xaxis: { title: axisLabelMx },
                    yaxis: { title: axisLabelMy },
                    zaxis: { title: axisLabelP },
                    aspectmode: 'manual',
                    aspectratio: { x: scaleXY, y: scaleXY, z: scaleZ }
                },
                margin: { l: 0, r: 0, b: 0, t: 30 },
                height: 500,
                autosize: true
            };

            // Remove old SVG if visible, use container
            document.getElementById('pm-chart-svg').style.display = 'none';
            document.getElementById('pm-chart-container').style.display = 'block';

            let container = document.getElementById('pm-chart-3d');
            if (!container) {
                const parent = document.getElementById('pm-chart-container');
                container = document.createElement('div');
                container.id = 'pm-chart-3d';
                parent.appendChild(container); // Append after SVG
            }
            container.style.display = 'block';

            Plotly.newPlot('pm-chart-3d', traces, layout);
        }

        // Apply default unit system
        if (document.getElementById('unit-system').value) {
            switchUnitSystem(document.getElementById('unit-system').value);
        }
    </script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</body>

</html>